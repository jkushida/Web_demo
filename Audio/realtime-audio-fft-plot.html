<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>リアルタイムFFTプロット（波形+スペクトラム）</title>
    <style>
      body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif; color: #222; }
      header, main { padding: 16px; }
      h1 { font-size: 18px; margin: 12px 0; }
      .panel { border: 1px solid #ddd; border-radius: 8px; padding: 12px; margin: 14px 0; background: #fff; }
      .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
      button { padding: 6px 12px; border: 1px solid #bbb; border-radius: 6px; background: #f5f5f5; cursor: pointer; }
      canvas { width: 100%; height: 220px; background: #000; border-radius: 6px; display: block; border: 1px solid #222; }
      .caption { margin-top: 6px; color: #666; font-size: 12px; }
      label { color: #444; font-size: 14px; }
      small { color: #666; }
    </style>
  </head>
  <body>
    <header>
      <h1>リアルタイムFFTプロット（波形+スペクトラム）</h1>
      <p><small>Python版（realtime_audio_fft_plot.py）相当。マイクの波形とFFTスペクトラムを同時に表示します。</small></p>
    </header>
    <main>
      <section class="panel">
        <div class="row" style="margin-bottom:8px;">
          <button id="btn">▶ Start</button>
          <label>FFTサイズ
            <select id="fft">
              <option selected>512</option>
              <option>1024</option>
              <option>2048</option>
            </select>
          </label>
          <label>スムージング<input id="smooth" type="range" min="0" max="0.9" step="0.05" value="0" /></label>
          <span id="info" style="color:#555; font-size:13px;">状態: idle</span>
        </div>

        <canvas id="cWave" width="1024" height="220"></canvas>
        <div class="caption"><small>y–tグラフ（y: 正規化振幅 −1..1, t: サンプル番号 0..N-1）。</small></div>
        <div style="height: 10px"></div>
        <canvas id="cSpec" width="1024" height="220"></canvas>
        <div class="caption"><small>|Y(f)|–f（横軸: 周波数[Hz], 縦軸: 相対振幅、オートスケール）。</small></div>
        <div class="caption">
          <small>
            目安（話声の基本周波数 f0）: 一般的な会話はおおよそ 85–180Hz、平均は約110Hz前後。高めに発声すると 150–180Hz 程度まで上がることがあります（個人差あり）。
          </small>
        </div>
      </section>
    </main>

    <script type="module">
      const btn = document.getElementById('btn');
      const info = document.getElementById('info');
      const fftSel = document.getElementById('fft');
      const smooth = document.getElementById('smooth');
      const cWave = document.getElementById('cWave');
      const cSpec = document.getElementById('cSpec');
      const gWave = cWave.getContext('2d');
      const gSpec = cSpec.getContext('2d');

      let ac, analyser, src, stream;
      let timeBuf, freqBuf; // Uint8Array
      let rafId = 0, running = false;

      function drawWaveAxes() {
        const w = cWave.width, h = cWave.height;
        const left = 46, right = 10, top = 12, bottom = 22;
        const plotW = w - left - right; const plotH = h - top - bottom;
        const y0 = top + plotH * 0.5;
        gWave.clearRect(0,0,w,h);
        gWave.strokeStyle = 'rgba(255,255,255,.35)'; gWave.strokeRect(left, top, plotW, plotH);
        gWave.setLineDash([6,6]);
        // +1, 0, -1 lines
        gWave.beginPath(); gWave.moveTo(left, top + plotH*0.05); gWave.lineTo(w - right, top + plotH*0.05); gWave.stroke();
        gWave.beginPath(); gWave.moveTo(left, y0); gWave.lineTo(w - right, y0); gWave.stroke();
        gWave.beginPath(); gWave.moveTo(left, top + plotH*0.95); gWave.lineTo(w - right, top + plotH*0.95); gWave.stroke();
        gWave.setLineDash([]);
        gWave.fillStyle = 'rgba(255,255,255,.95)'; gWave.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        gWave.fillText('+1', 6, top + plotH*0.05 + 10);
        gWave.fillText('0', 6, y0 - 2);
        gWave.fillText('-1', 6, top + plotH*0.95);
      }

      function drawSpecAxes() {
        const w = cSpec.width, h = cSpec.height;
        const left = 46, right = 10, top = 12, bottom = 24;
        const plotW = w - left - right; const plotH = h - top - bottom;
        gSpec.clearRect(0,0,w,h);
        gSpec.strokeStyle = 'rgba(255,255,255,.35)'; gSpec.strokeRect(left, top, plotW, plotH);
        // Freq ticks
        const fs = ac ? ac.sampleRate : 48000; const nyq = fs / 2;
        const ticks = [50, 100, 200, 500, 1000, 2000, 5000, 10000];
        gSpec.textAlign = 'center'; gSpec.fillStyle = 'rgba(255,255,255,.95)'; gSpec.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        let lastLabeledX = -1e9; const minLabelGap = 46; // px
        for (const f of ticks) {
          if (f > nyq) break; const x = left + (f / nyq) * plotW;
          // グリッドは全て描く
          gSpec.save(); gSpec.setLineDash([4,8]); gSpec.strokeStyle = 'rgba(255,255,255,.22)';
          gSpec.beginPath(); gSpec.moveTo(x, top); gSpec.lineTo(x, top + plotH); gSpec.stroke(); gSpec.restore();
          // 目盛（下端）
          gSpec.beginPath(); gSpec.moveTo(x, top + plotH); gSpec.lineTo(x, top + plotH + 6); gSpec.strokeStyle = 'rgba(255,255,255,.5)'; gSpec.stroke();
          // ラベルは一定間隔以上あくものだけ描画（重なり防止）
          if (x - lastLabeledX >= minLabelGap) {
            const label = f >= 1000 ? `${Math.round(f/1000)}k` : String(f);
            gSpec.fillText(label, x, h - 6);
            lastLabeledX = x;
          }
        }
        // Summary
        gSpec.textAlign = 'right'; gSpec.fillText(`fs≈${ac?Math.round(ac.sampleRate):'—'} Hz, fft=${analyser?analyser.fftSize:'—'}`, w - 6, top + 14);
        gSpec.textAlign = 'start';
      }

      function draw() {
        analyser.getByteTimeDomainData(timeBuf);
        analyser.getByteFrequencyData(freqBuf);

        // Waveform
        drawWaveAxes();
        const w = cWave.width, h = cWave.height; const left = 46, right = 10, top = 12, bottom = 22;
        const plotW = w - left - right; const plotH = h - top - bottom; const y0 = top + plotH * 0.5; const amp = plotH * 0.45;
        gWave.strokeStyle = '#00e676'; gWave.lineWidth = 2.0; gWave.beginPath();
        const Nt = timeBuf.length;
        for (let i = 0; i < Nt; i++) {
          const x = left + (i / (Nt - 1)) * plotW;
          const v = (timeBuf[i] - 128) / 128; // -1..1
          const y = y0 - v * amp;
          if (i === 0) gWave.moveTo(x, y); else gWave.lineTo(x, y);
        }
        gWave.stroke();

        // Spectrum (line)
        drawSpecAxes();
        const ws = cSpec.width, hs = cSpec.height; const l2 = 46, r2 = 10, t2 = 12, b2 = 24;
        const plotWs = ws - l2 - r2; const plotHs = hs - t2 - b2; const y0s = t2 + plotHs;
        const Nf = freqBuf.length; // fftSize/2
        // autoscale by max
        let maxMag = 0; for (let i = 0; i < Nf; i++) { if (freqBuf[i] > maxMag) maxMag = freqBuf[i]; }
        const scale = maxMag > 0 ? plotHs / maxMag : 1;
        gSpec.strokeStyle = '#4fc3f7'; gSpec.lineWidth = 1.6; gSpec.beginPath();
        for (let i = 0; i < Nf; i++) {
          const x = l2 + (i / (Nf - 1)) * plotWs;
          const y = y0s - freqBuf[i] * scale;
          if (i === 0) gSpec.moveTo(x, y); else gSpec.lineTo(x, y);
        }
        gSpec.stroke();

        if (running) rafId = requestAnimationFrame(draw);
      }

      async function start() {
        if (running) return;
        try {
          stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
          ac = new (window.AudioContext || window.webkitAudioContext)();
          src = ac.createMediaStreamSource(stream);
          analyser = ac.createAnalyser();
          analyser.fftSize = parseInt(fftSel.value, 10);
          analyser.smoothingTimeConstant = parseFloat(smooth.value);
          src.connect(analyser);
          timeBuf = new Uint8Array(analyser.fftSize);
          freqBuf = new Uint8Array(analyser.frequencyBinCount);
          running = true; btn.textContent = '⏸ Stop';
          info.textContent = `状態: running | fs≈${Math.round(ac.sampleRate)}Hz, fft=${analyser.fftSize}`;
          draw();
        } catch (e) {
          console.error(e); info.textContent = '状態: error - マイク権限を確認してください';
        }
      }

      function stop() {
        if (!running) return;
        running = false;
        cancelAnimationFrame(rafId);
        if (ac?.state !== 'closed') ac.close().catch(() => {});
        stream?.getTracks?.().forEach(t => t.stop());
        btn.textContent = '▶ Start'; info.textContent = '状態: stopped';
      }

      // UI handlers
      btn.addEventListener('click', () => { running ? stop() : start(); });
      fftSel.addEventListener('change', () => { if (analyser) { analyser.fftSize = parseInt(fftSel.value, 10); timeBuf = new Uint8Array(analyser.fftSize); freqBuf = new Uint8Array(analyser.frequencyBinCount); }});
      smooth.addEventListener('input', () => { if (analyser) analyser.smoothingTimeConstant = parseFloat(smooth.value); });
      window.addEventListener('pagehide', stop);
      window.addEventListener('beforeunload', stop);
    </script>
  </body>
  </html>
