<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ„Ÿæƒ…ã®é¡ - Emotion Recognition Enhanced</title>
    
    <!-- MediaPipe CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    
    <!-- Face-api.js for AI Emotion Recognition -->
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            display: flex;
            gap: 30px;
            max-width: 1400px;
            width: 100%;
        }

        .video-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .video-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            aspect-ratio: 4/3;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            background: #000;
        }

        #inputVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            display: none;
        }

        #outputCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        .video-controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .toggle-button {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            font-weight: bold;
        }

        .toggle-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .toggle-button.active {
            background: rgba(255, 255, 255, 0.4);
            border-color: #fff;
        }

        .controls-section {
            flex: 0 0 400px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
        }

        h1 {
            font-size: 32px;
            margin-bottom: 10px;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 30px;
            font-size: 14px;
        }

        .status-message {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .status-message.error {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.5);
        }

        .status-message.success {
            background: rgba(34, 197, 94, 0.2);
            border: 1px solid rgba(34, 197, 94, 0.5);
        }

        .status-message.loading {
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.5);
            animation: pulse 2s infinite;
        }

        .emotion-display {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .current-emotion {
            font-size: 72px;
            margin-bottom: 10px;
        }

        .emotion-name {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .confidence {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
        }

        .emotion-meters {
            margin-bottom: 20px;
        }

        .emotion-meter {
            margin-bottom: 15px;
        }

        .emotion-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .emotion-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
        }

        .emotion-fill {
            height: 100%;
            border-radius: 5px;
            transition: width 0.3s ease;
        }

        .emotion-fill.happy {
            background: linear-gradient(90deg, #FFD700, #FFA500);
        }

        .emotion-fill.sad {
            background: linear-gradient(90deg, #4169E1, #1E90FF);
        }

        .emotion-fill.angry {
            background: linear-gradient(90deg, #DC143C, #FF6347);
        }

        .emotion-fill.surprised {
            background: linear-gradient(90deg, #FF69B4, #FFB6C1);
        }

        .emotion-fill.neutral {
            background: linear-gradient(90deg, #708090, #A9A9A9);
        }

        .settings {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .setting-group {
            margin-bottom: 15px;
        }

        .setting-label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .slider {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            border: none;
            cursor: pointer;
        }

        .debug-info {
            margin-top: 20px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            font-size: 12px;
            font-family: monospace;
        }

        .debug-item {
            margin: 5px 0;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .pulse {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="video-section">
            <div class="video-container">
                <video id="inputVideo" autoplay playsinline></video>
                <canvas id="outputCanvas"></canvas>
            </div>
            <div class="video-controls">
                <button class="toggle-button active" id="landmarksToggle" onclick="toggleLandmarks()">
                    ğŸ‘ï¸ ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯è¡¨ç¤º
                </button>
                <button class="toggle-button active" id="meshToggle" onclick="toggleMesh()">
                    ğŸ”— ãƒ¡ãƒƒã‚·ãƒ¥è¡¨ç¤º
                </button>
                
            </div>
        </div>

        <div class="controls-section">
            <h1>ğŸ­ æ„Ÿæƒ…ã®é¡</h1>
            <p class="subtitle">Face-api.js AIæ„Ÿæƒ…èªè­˜ + MediaPipe Face Mesh v2.0</p>

            <div class="status-message" id="statusMessage">
                ğŸš€ ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ä¸­... AIæ„Ÿæƒ…èªè­˜ãƒ¢ãƒ‡ãƒ«ã‚’æº–å‚™ã—ã¦ã„ã¾ã™
            </div>

            <div class="emotion-display">
                <div class="current-emotion pulse" id="currentEmoji">ğŸ­</div>
                <div class="emotion-name" id="currentEmotion">å¾…æ©Ÿä¸­</div>
                <div class="confidence">ä¿¡é ¼åº¦: <span id="confidence">0</span>%</div>
            </div>

            <div class="emotion-meters">
                <div class="emotion-meter">
                    <div class="emotion-label">
                        <span>ğŸ˜Š å–œã³</span>
                        <span id="happy-value">0%</span>
                    </div>
                    <div class="emotion-bar">
                        <div class="emotion-fill happy" id="happy-bar" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="emotion-meter">
                    <div class="emotion-label">
                        <span>ğŸ˜¢ æ‚²ã—ã¿</span>
                        <span id="sad-value">0%</span>
                    </div>
                    <div class="emotion-bar">
                        <div class="emotion-fill sad" id="sad-bar" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="emotion-meter">
                    <div class="emotion-label">
                        <span>ğŸ˜  æ€’ã‚Š</span>
                        <span id="angry-value">0%</span>
                    </div>
                    <div class="emotion-bar">
                        <div class="emotion-fill angry" id="angry-bar" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="emotion-meter">
                    <div class="emotion-label">
                        <span>ğŸ˜² é©šã</span>
                        <span id="surprised-value">0%</span>
                    </div>
                    <div class="emotion-bar">
                        <div class="emotion-fill surprised" id="surprised-bar" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="emotion-meter">
                    <div class="emotion-label">
                        <span>ğŸ˜ ä¸­ç«‹</span>
                        <span id="neutral-value">0%</span>
                    </div>
                    <div class="emotion-bar">
                        <div class="emotion-fill neutral" id="neutral-bar" style="width: 0%"></div>
                    </div>
                </div>
            </div>

            <div class="settings">
                <h3>âš™ï¸ è¨­å®š</h3>
                <div class="setting-group">
                    <label class="setting-label">
                        æ„Ÿåº¦ (å–œã³): <span id="happySensitivity-value">50</span>%
                    </label>
                    <input type="range" class="slider" id="happySensitivity" 
                           min="10" max="100" value="50" oninput="updateSensitivity('happy')">
                </div>
                <div class="setting-group">
                    <label class="setting-label">
                        æ„Ÿåº¦ (å…¨ä½“): <span id="overallSensitivity-value">50</span>%
                    </label>
                    <input type="range" class="slider" id="overallSensitivity" 
                           min="10" max="100" value="50" oninput="updateSensitivity('overall')">
                </div>
            </div>

            <div class="debug-info" id="debugInfo">
                <div class="debug-item">ğŸ“Š FPS: <span id="fps">0</span></div>
                <div class="debug-item">ğŸ‘¤ é¡”æ¤œå‡º: <span id="faceDetected">ãªã—</span></div>
                <div class="debug-item">ğŸ“ ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯: <span id="landmarkCount">0</span></div>
                <div class="debug-item">ğŸ˜Š å£è§’ä¸Šæ˜‡å€¤: <span id="smileValue">0.00</span></div>
                <div class="debug-item">ğŸ‘„ å£ã®é–‹ã: <span id="mouthOpen">0.00</span></div>
            </div>
        </div>
    </div>

    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let videoElement = document.getElementById('inputVideo');
        let canvasElement = document.getElementById('outputCanvas');
        let canvasCtx = canvasElement.getContext('2d');
        let camera = null;
        let faceMesh = null;
        let isRunning = false;
        let lastFrameTime = Date.now();
        let frameCount = 0;
        
        // è¡¨ç¤ºè¨­å®š
        let showLandmarks = true;
        let showMesh = true;
        let showVideo = false;
        
        // æ„Ÿåº¦è¨­å®š
        let happySensitivity = 50;
        let overallSensitivity = 50;
        
        // Face-api.js å¤‰æ•°ï¼ˆAIæ„Ÿæƒ…èªè­˜ç”¨ï¼‰
        let faceApiModelsLoaded = false;
        let lastEmotionDetection = null;
        let isDetectingEmotion = false;
        
        // æ„Ÿæƒ…ã®çµµæ–‡å­—ã¨åå‰
        const emotionEmojis = {
            happy: 'ğŸ˜Š',
            sad: 'ğŸ˜¢',
            angry: 'ğŸ˜ ',
            surprised: 'ğŸ˜²',
            neutral: 'ğŸ˜'
        };
        
        const emotionNames = {
            happy: 'å–œã³',
            sad: 'æ‚²ã—ã¿',
            angry: 'æ€’ã‚Š',
            surprised: 'é©šã',
            neutral: 'ä¸­ç«‹'
        };
        
        // ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆMediaPipe Face Meshï¼‰
        const LANDMARKS = {
            // å£ã®å‘¨ã‚Š
            MOUTH_LEFT: 61,
            MOUTH_RIGHT: 291,
            MOUTH_TOP: 13,
            MOUTH_BOTTOM: 14,
            UPPER_LIP_TOP: 12,
            LOWER_LIP_BOTTOM: 15,
            MOUTH_CENTER: 13,
            
            // å£è§’
            LEFT_MOUTH_CORNER: 61,
            RIGHT_MOUTH_CORNER: 291,
            
            // ç›®
            LEFT_EYE_TOP: 159,
            LEFT_EYE_BOTTOM: 145,
            RIGHT_EYE_TOP: 386,
            RIGHT_EYE_BOTTOM: 374,
            
            // çœ‰
            LEFT_EYEBROW_INNER: 70,
            LEFT_EYEBROW_OUTER: 63,
            RIGHT_EYEBROW_INNER: 107,
            RIGHT_EYEBROW_OUTER: 55,
            
            // é ¬
            LEFT_CHEEK: 116,
            RIGHT_CHEEK: 345
        };
        
        // è‡ªå‹•èµ·å‹•
        window.addEventListener('DOMContentLoaded', () => {
            console.log('DOM Content Loaded - è‡ªå‹•èµ·å‹•é–‹å§‹');
            loadFaceApiModels(); // Face-api.jsãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã¿
            setTimeout(startDetection, 1000); // 1ç§’å¾Œã«è‡ªå‹•èµ·å‹•
        });
        
        // Face-api.jsã®ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚€
        async function loadFaceApiModels() {
            try {
                updateStatus('ğŸ¤– AIæ„Ÿæƒ…èªè­˜ãƒ¢ãƒ‡ãƒ«æº–å‚™ä¸­... (åˆå›ã¯æ•°ç§’ã‹ã‹ã‚Šã¾ã™)', 'loading');
                console.log('Face-api.js ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿ã‚’é–‹å§‹...');
                const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.12/model';
                
                // æ„Ÿæƒ…èªè­˜ã«å¿…è¦ãªãƒ¢ãƒ‡ãƒ«ã®ã¿ã‚’èª­ã¿è¾¼ã‚€
                await Promise.all([
                    faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
                    faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL)
                ]);
                
                faceApiModelsLoaded = true;
                console.log('Face-api.js ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿å®Œäº†ï¼');
                updateStatus('âœ… AIæ„Ÿæƒ…èªè­˜ãƒ¢ãƒ‡ãƒ«æº–å‚™å®Œäº†ï¼', 'success');
            } catch (error) {
                console.error('Face-api.js ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                faceApiModelsLoaded = false;
                updateStatus('âš ï¸ AIãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å¤±æ•— - ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹æ¨å®šã§å‹•ä½œã—ã¾ã™', 'error');
            }
        }
        
        function setupCanvas() {
            canvasElement.width = 640;
            canvasElement.height = 480;
        }
        
        async function startDetection() {
            try {
                // AIãƒ¢ãƒ‡ãƒ«ã®æº–å‚™ã‚’å¾…ã¤
                if (!faceApiModelsLoaded) {
                    updateStatus('â³ AIæ„Ÿæƒ…èªè­˜ãƒ¢ãƒ‡ãƒ«ã®æº–å‚™ã‚’å¾…ã£ã¦ã„ã¾ã™...', 'loading');
                    // ãƒ¢ãƒ‡ãƒ«ãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§å¾…æ©Ÿï¼ˆæœ€å¤§10ç§’ï¼‰
                    let waitCount = 0;
                    while (!faceApiModelsLoaded && waitCount < 50) {
                        await new Promise(resolve => setTimeout(resolve, 200));
                        waitCount++;
                    }
                    
                    if (!faceApiModelsLoaded) {
                        updateStatus('âš ï¸ AIãƒ¢ãƒ‡ãƒ«æº–å‚™ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ - ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã§èµ·å‹•ã—ã¾ã™', 'error');
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }
                
                updateStatus('ğŸ“¹ ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•ä¸­...', 'loading');
                await setupCamera();
                
                updateStatus('ğŸ”„ MediaPipeã‚’åˆæœŸåŒ–ä¸­...', 'loading');
                await setupFaceMesh();
                
                const modelStatus = faceApiModelsLoaded ? 'ğŸ¤– AIæ„Ÿæƒ…èªè­˜' : 'ğŸ“Š ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹æ¨å®š';
                updateStatus(`âœ… æ„Ÿæƒ…èªè­˜ã‚’é–‹å§‹ã—ã¾ã—ãŸ (${modelStatus})`, 'success');
                isRunning = true;
                
            } catch (error) {
                console.error('ã‚¨ãƒ©ãƒ¼:', error);
                updateStatus('âŒ ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
            }
        }
        
        async function setupCamera() {
            console.log('ã‚«ãƒ¡ãƒ©ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—é–‹å§‹');
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: 640,
                        height: 480,
                        facingMode: 'user'
                    }
                });
                
                videoElement.srcObject = stream;
                videoElement.style.display = 'block';
                
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        console.log('ã‚«ãƒ¡ãƒ©æº–å‚™å®Œäº†');
                        setupCanvas();
                        resolve();
                    };
                });
                
            } catch (error) {
                console.error('ã‚«ãƒ¡ãƒ©ã‚¨ãƒ©ãƒ¼:', error);
                throw new Error('ã‚«ãƒ¡ãƒ©ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“');
            }
        }
        
        async function setupFaceMesh() {
            console.log('MediaPipe FaceMeshåˆæœŸåŒ–é–‹å§‹');
            
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }
            });
            
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            faceMesh.onResults(onResults);
            
            camera = new Camera(videoElement, {
                onFrame: async () => {
                    if (faceMesh && isRunning) {
                        await faceMesh.send({image: videoElement});
                    }
                },
                width: 640,
                height: 480
            });
            
            camera.start();
            console.log('ã‚«ãƒ¡ãƒ©ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°é–‹å§‹');
        }
        
        async function onResults(results) {
            // FPSè¨ˆç®—
            frameCount++;
            const now = Date.now();
            if (now - lastFrameTime > 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFrameTime = now;
            }
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªã‚¢
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // ãƒ“ãƒ‡ã‚ªãƒ•ãƒ¬ãƒ¼ãƒ æç”»
            if (showVideo) {
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            }
            
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                document.getElementById('faceDetected').textContent = 'ã‚ã‚Š';
                document.getElementById('landmarkCount').textContent = landmarks.length;
                
                // ãƒ¡ãƒƒã‚·ãƒ¥æç”»
                if (showMesh) {
                    drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, 
                        {color: '#C0C0C070', lineWidth: 1});
                    drawConnectors(canvasCtx, landmarks, FACEMESH_FACE_OVAL, 
                        {color: '#E0E0E0', lineWidth: 2});
                }
                
                // ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯æç”»
                if (showLandmarks) {
                    // é‡è¦ãªãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã‚’å¼·èª¿è¡¨ç¤º
                    drawImportantLandmarks(landmarks);
                    
                    // å£ã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã‚’ç‰¹åˆ¥ã«è¡¨ç¤º
                    drawConnectors(canvasCtx, landmarks, FACEMESH_LIPS, 
                        {color: '#FF3030', lineWidth: 2});
                }
                
                // AIæ„Ÿæƒ…æ¨å®š
                const emotions = await estimateEmotions(landmarks);
                updateEmotionDisplay(emotions);
                
            } else {
                document.getElementById('faceDetected').textContent = 'ãªã—';
                document.getElementById('landmarkCount').textContent = '0';
            }
            
            canvasCtx.restore();
        }
        
        function drawImportantLandmarks(landmarks) {
            // å£è§’ã‚’èµ¤ã§è¡¨ç¤º
            canvasCtx.fillStyle = '#FF0000';
            drawLandmark(landmarks[LANDMARKS.LEFT_MOUTH_CORNER], 5);
            drawLandmark(landmarks[LANDMARKS.RIGHT_MOUTH_CORNER], 5);
            
            // å£ã®ä¸­å¿ƒã‚’é’ã§è¡¨ç¤º
            canvasCtx.fillStyle = '#0000FF';
            drawLandmark(landmarks[LANDMARKS.MOUTH_TOP], 4);
            drawLandmark(landmarks[LANDMARKS.MOUTH_BOTTOM], 4);
            
            // ç›®ã‚’ç·‘ã§è¡¨ç¤º
            canvasCtx.fillStyle = '#00FF00';
            drawLandmark(landmarks[LANDMARKS.LEFT_EYE_TOP], 3);
            drawLandmark(landmarks[LANDMARKS.LEFT_EYE_BOTTOM], 3);
            drawLandmark(landmarks[LANDMARKS.RIGHT_EYE_TOP], 3);
            drawLandmark(landmarks[LANDMARKS.RIGHT_EYE_BOTTOM], 3);
            
            // çœ‰ã‚’é»„è‰²ã§è¡¨ç¤ºï¼ˆå†…å´ã¨å¤–å´ï¼‰
            canvasCtx.fillStyle = '#FFFF00';
            drawLandmark(landmarks[LANDMARKS.LEFT_EYEBROW_INNER], 3);
            drawLandmark(landmarks[LANDMARKS.LEFT_EYEBROW_OUTER], 3);
            drawLandmark(landmarks[LANDMARKS.RIGHT_EYEBROW_INNER], 3);
            drawLandmark(landmarks[LANDMARKS.RIGHT_EYEBROW_OUTER], 3);
        }
        
        function drawLandmark(landmark, size = 3) {
            if (!landmark) return;
            canvasCtx.beginPath();
            canvasCtx.arc(
                landmark.x * canvasElement.width,
                landmark.y * canvasElement.height,
                size, 0, 2 * Math.PI
            );
            canvasCtx.fill();
        }
        
        function getDefaultEmotions() {
            return {
                happy: 0,
                sad: 0,
                angry: 0,
                surprised: 0,
                neutral: 100
            };
        }
        
        async function estimateEmotions(landmarks) {
            // Face-api.jsãƒ¢ãƒ‡ãƒ«ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ãªã„å ´åˆã¯ã€å¾“æ¥ã®ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹æ¨å®šã‚’ä½¿ç”¨
            if (!faceApiModelsLoaded) {
                return estimateEmotionsRuleBased(landmarks);
            }
            
            // æ—¢ã«æ¤œå‡ºä¸­ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šï¼‰
            if (isDetectingEmotion) {
                return lastEmotionDetection || getDefaultEmotions();
            }
            
            try {
                isDetectingEmotion = true;
                
                // Face-api.jsã§æ„Ÿæƒ…ã‚’æ¤œå‡º
                const detections = await faceapi
                    .detectSingleFace(videoElement, new faceapi.TinyFaceDetectorOptions())
                    .withFaceExpressions();
                
                if (detections && detections.expressions) {
                    const expressions = detections.expressions;
                    
                    // Face-api.jsã®7ã¤ã®æ„Ÿæƒ…ã‚’5ã¤ã«ãƒãƒƒãƒ”ãƒ³ã‚°
                    const emotions = {
                        happy: (expressions.happy || 0) * 100,
                        sad: (expressions.sad || 0) * 100,
                        angry: (expressions.angry || 0) * 100,
                        surprised: (expressions.surprised || 0) * 100,
                        neutral: ((expressions.neutral || 0) + (expressions.disgusted || 0) * 0.3 + (expressions.fearful || 0) * 0.3) * 100
                    };
                    
                    // ãƒ‡ãƒãƒƒã‚°å€¤ã‚’æ›´æ–°ï¼ˆAIæ¤œå‡ºã‚’ç¤ºã™ï¼‰
                    const mouthSmile = (expressions.happy - expressions.sad) * 0.01;
                    const mouthOpen = expressions.surprised * 0.01;
                    document.getElementById('smileValue').textContent = mouthSmile.toFixed(4) + ' (AI)';
                    document.getElementById('mouthOpen').textContent = mouthOpen.toFixed(4) + ' (AI)';
                    
                    // æ„Ÿåº¦èª¿æ•´ã‚’é©ç”¨
                    const happyMultiplier = happySensitivity / 50;
                    const overallMultiplier = overallSensitivity / 50;
                    
                    emotions.happy *= happyMultiplier;
                    emotions.sad *= overallMultiplier;
                    emotions.angry *= overallMultiplier;
                    emotions.surprised *= overallMultiplier;
                    
                    // æ­£è¦åŒ–
                    const total = Object.values(emotions).reduce((a, b) => a + b, 0);
                    if (total > 0) {
                        for (let emotion in emotions) {
                            emotions[emotion] = Math.round((emotions[emotion] / total) * 100);
                        }
                    }
                    
                    lastEmotionDetection = emotions;
                    isDetectingEmotion = false;
                    return emotions;
                }
            } catch (error) {
                console.error('AIæ„Ÿæƒ…æ¤œå‡ºã‚¨ãƒ©ãƒ¼:', error);
            }
            
            isDetectingEmotion = false;
            
            // æ¤œå‡ºå¤±æ•—æ™‚ã¯æœ€å¾Œã®çµæœã‚’è¿”ã™ã‹ã€ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            if (lastEmotionDetection) {
                return lastEmotionDetection;
            }
            
            return estimateEmotionsRuleBased(landmarks);
        }
        
        // å¾“æ¥ã®ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹æ„Ÿæƒ…æ¨å®šï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ï¼‰
        function estimateEmotionsRuleBased(landmarks) {
            const emotions = {
                happy: 0,
                sad: 0,
                angry: 0,
                surprised: 0,
                neutral: 30
            };
            
            try {
                // å£è§’ã®ä¸Šæ˜‡ã‚’è¨ˆç®—ï¼ˆå–œã³ï¼‰
                const leftMouth = landmarks[LANDMARKS.LEFT_MOUTH_CORNER];
                const rightMouth = landmarks[LANDMARKS.RIGHT_MOUTH_CORNER];
                const mouthTop = landmarks[LANDMARKS.MOUTH_TOP];
                const mouthBottom = landmarks[LANDMARKS.MOUTH_BOTTOM];
                
                // å£è§’ã®å¹³å‡Yåº§æ¨™
                const mouthCornersY = (leftMouth.y + rightMouth.y) / 2;
                // å£ã®ä¸­å¿ƒYåº§æ¨™
                const mouthCenterY = (mouthTop.y + mouthBottom.y) / 2;
                
                // å£è§’ãŒä¸ŠãŒã£ã¦ã„ã‚‹åº¦åˆã„ï¼ˆå€¤ãŒå°ã•ã„ã»ã©ä¸ŠãŒã£ã¦ã„ã‚‹ï¼‰
                const mouthSmile = mouthCenterY - mouthCornersY;
                
                // å£ã®é–‹ãå…·åˆ
                const mouthOpenness = Math.abs(mouthBottom.y - mouthTop.y);
                
                // ãƒ‡ãƒãƒƒã‚°å€¤è¡¨ç¤º
                document.getElementById('smileValue').textContent = mouthSmile.toFixed(4);
                document.getElementById('mouthOpen').textContent = mouthOpenness.toFixed(4);
                
                // å–œã³ã®åˆ¤å®šï¼ˆèª¿æ•´ç‰ˆï¼‰
                const happyMultiplier = happySensitivity / 50;
                if (mouthSmile > 0.005) { // é–¾å€¤ã‚’ä¸‹ã’ãŸ
                    emotions.happy = Math.min(100, mouthSmile * 3000 * happyMultiplier);
                    
                    // å£ãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã¯ç¬‘é¡”ã®å¯èƒ½æ€§ãŒé«˜ã„
                    if (mouthOpenness > 0.02) {
                        emotions.happy = Math.min(100, emotions.happy * 1.5);
                    }
                }
                
                // æ‚²ã—ã¿ã®åˆ¤å®š
                if (mouthSmile < -0.005) {
                    emotions.sad = Math.min(100, Math.abs(mouthSmile) * 2000 * (overallSensitivity / 50));
                }
                
                // çœ‰é–“ã®è·é›¢ã‹ã‚‰æ€’ã‚Šã‚’æ¨å®š
                const leftBrow = landmarks[LANDMARKS.LEFT_EYEBROW_INNER];
                const rightBrow = landmarks[LANDMARKS.RIGHT_EYEBROW_INNER];
                const browDistance = Math.abs(leftBrow.x - rightBrow.x);
                
                if (browDistance < 0.08) {
                    emotions.angry = Math.min(100, (0.08 - browDistance) * 1000 * (overallSensitivity / 50));
                }
                
                // ç›®ã®é–‹ãå…·åˆã‹ã‚‰é©šãã‚’æ¨å®š
                const leftEyeOpen = Math.abs(landmarks[LANDMARKS.LEFT_EYE_BOTTOM].y - landmarks[LANDMARKS.LEFT_EYE_TOP].y);
                const rightEyeOpen = Math.abs(landmarks[LANDMARKS.RIGHT_EYE_BOTTOM].y - landmarks[LANDMARKS.RIGHT_EYE_TOP].y);
                const eyeOpenness = (leftEyeOpen + rightEyeOpen) / 2;
                
                if (eyeOpenness > 0.03) {
                    emotions.surprised = Math.min(100, eyeOpenness * 2000 * (overallSensitivity / 50));
                }
                
                // ä¸­ç«‹ã®èª¿æ•´
                const totalEmotions = emotions.happy + emotions.sad + emotions.angry + emotions.surprised;
                if (totalEmotions < 50) {
                    emotions.neutral = 100 - totalEmotions;
                } else {
                    emotions.neutral = Math.max(0, 30 - totalEmotions / 3);
                }
                
                // æ­£è¦åŒ–
                const total = Object.values(emotions).reduce((a, b) => a + b, 0);
                if (total > 0) {
                    for (let emotion in emotions) {
                        emotions[emotion] = Math.round((emotions[emotion] / total) * 100);
                    }
                }
                
            } catch (error) {
                console.error('æ„Ÿæƒ…æ¨å®šã‚¨ãƒ©ãƒ¼:', error);
            }
            
            return emotions;
        }
        
        function updateEmotionDisplay(emotions) {
            // æœ€ã‚‚å¼·ã„æ„Ÿæƒ…ã‚’ç‰¹å®š
            let maxEmotion = 'neutral';
            let maxValue = 0;
            
            for (let emotion in emotions) {
                const value = emotions[emotion];
                
                // ãƒãƒ¼ã‚’æ›´æ–°
                document.getElementById(`${emotion}-bar`).style.width = value + '%';
                document.getElementById(`${emotion}-value`).textContent = value + '%';
                
                if (value > maxValue) {
                    maxValue = value;
                    maxEmotion = emotion;
                }
            }
            
            // ç¾åœ¨ã®æ„Ÿæƒ…ã‚’è¡¨ç¤º
            const emojiElement = document.getElementById('currentEmoji');
            const currentEmoji = emotionEmojis[maxEmotion];
            if (emojiElement.textContent !== currentEmoji) {
                emojiElement.textContent = currentEmoji;
                emojiElement.classList.add('pulse');
                setTimeout(() => emojiElement.classList.remove('pulse'), 2000);
            }
            
            document.getElementById('currentEmotion').textContent = emotionNames[maxEmotion];
            document.getElementById('confidence').textContent = maxValue;
        }
        
        function updateStatus(message, type = '') {
            const statusElement = document.getElementById('statusMessage');
            statusElement.textContent = message;
            statusElement.className = 'status-message';
            
            if (type === 'error') {
                statusElement.classList.add('error');
            } else if (type === 'success') {
                statusElement.classList.add('success');
            } else if (type === 'loading') {
                statusElement.classList.add('loading');
            }
        }
        
        // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«é–¢æ•°
        function toggleLandmarks() {
            showLandmarks = !showLandmarks;
            document.getElementById('landmarksToggle').classList.toggle('active');
        }
        
        function toggleMesh() {
            showMesh = !showMesh;
            document.getElementById('meshToggle').classList.toggle('active');
        }
        
        // ãƒ“ãƒ‡ã‚ªè¡¨ç¤ºã¯å¸¸æ™‚ã‚ªãƒ•ï¼ˆæç”»è² è·è»½æ¸›ã®ãŸã‚ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã¿ä½¿ç”¨ï¼‰
        
        // ä¸€æ™‚åœæ­¢æ©Ÿèƒ½ã¯å‰Šé™¤ï¼ˆå¸¸æ™‚å‡¦ç†ï¼‰
        
        function updateSensitivity(type) {
            if (type === 'happy') {
                happySensitivity = parseInt(document.getElementById('happySensitivity').value);
                document.getElementById('happySensitivity-value').textContent = happySensitivity;
            } else {
                overallSensitivity = parseInt(document.getElementById('overallSensitivity').value);
                document.getElementById('overallSensitivity-value').textContent = overallSensitivity;
            }
        }
    </script>
</body>
</html>
