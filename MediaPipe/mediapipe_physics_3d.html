<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaPipe + 3D Physics Engine Demo (Mirror Mode)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #videoElement {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            height: 240px;
            border: 3px solid rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            z-index: 10;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            /* é¡åƒè¡¨ç¤ºãªã— - ã‚«ãƒ¡ãƒ©ã«æ‰‹ã®ã²ã‚‰ã‚’å‘ã‘ã‚‹ã¨æ‰‹ã®ç”²ãŒæ˜ ã‚‹ */
        }
        
        #canvasElement {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            height: 240px;
            z-index: 11;
            pointer-events: none;
            /* é¡åƒè¡¨ç¤ºãªã— */
        }
        
        #output {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 10;
            max-width: 350px;
        }
        
        h1 {
            font-size: 24px;
            margin-bottom: 15px;
            color: #667eea;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        
        .info {
            margin: 10px 0;
            font-size: 14px;
            line-height: 1.6;
            color: #333;
        }
        
        .status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            margin-top: 10px;
        }
        
        .status.active {
            background: #4ade80;
            color: white;
        }
        
        .status.inactive {
            background: #f87171;
            color: white;
        }
        
        .controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        button.active {
            background: #4ade80;
        }
        
        #renderer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .instruction {
            background: #fef3c7;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 13px;
            color: #92400e;
            border-left: 4px solid #fbbf24;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="renderer"></canvas>
        <video id="videoElement" autoplay playsinline></video>
        <canvas id="canvasElement"></canvas>
        
        <div id="output">
            <h1>ğŸ® 3D Physics Ã— MediaPipe</h1>
            <div class="info">
                <strong>æ¤œå‡ºçŠ¶æ…‹:</strong> <span class="status inactive" id="status">æœªæ¤œå‡º</span>
            </div>
            <div class="info">
                <strong>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°:</strong> <span id="objectCount">0</span>
            </div>
            <div class="info">
                <strong>å‰Šé™¤æ•°:</strong> <span id="removedCount">0</span>
            </div>
            <div class="info">
                <strong>ç‰©ç†æ¼”ç®—FPS:</strong> <span id="physicsFPS">0</span>
            </div>
            <div class="info">
                <strong>æ‰‹ã®é€Ÿåº¦:</strong> <span id="handSpeed">0.0</span> m/s
            </div>
            <div class="info">
                <strong>åŠ é€Ÿåº¦:</strong> <span id="handAccel">0.0</span> m/sÂ²
            </div>
            <div class="info" style="background: #ffe4e6; padding: 5px; border-radius: 3px;">
                <strong>MediaPipeç”ŸZå€¤:</strong> <span id="rawZ">0.0</span>
            </div>
            <div class="controls">
                <button id="addBox">ğŸ“¦ ç®±ã‚’è¿½åŠ </button>
                <button id="addSphere">âš½ çƒã‚’è¿½åŠ </button>
                <button id="toggleSkeleton" class="active">ğŸ¦´ ã‚¹ã‚±ãƒ«ãƒˆãƒ³è¡¨ç¤º</button>
                <button id="reset">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
            <div class="instruction">
                <strong>ğŸ’¡ ä½¿ã„æ–¹:</strong><br>
                âœ‹ ã‚«ãƒ¡ãƒ©ã«æ‰‹ã®ã²ã‚‰ã‚’å‘ã‘ã‚‹ï¼ˆç”»é¢ã«ã¯æ‰‹ã®ç”²ãŒæ˜ ã‚Šã¾ã™ï¼‰<br>
                ğŸ“ ã‚«ãƒ¡ãƒ©ã«æ‰‹ã‚’è¿‘ã¥ã‘ã‚‹ã¨3Dç©ºé–“ã§å¥¥ã«ç§»å‹•ã—ã¾ã™<br>
                ğŸ‘† äººå·®ã—æŒ‡ã¨è¦ªæŒ‡ã§ã¤ã¾ã‚“ã§ç‰©ä½“ã‚’ã¤ã‹ã‚€<br>
                ğŸ–ï¸ æ‰‹ã‚’é–‹ã„ã¦ç‰©ä½“ã‚’æŠ•ã’ã‚‹<br>
                ğŸ¦´ æ‰‹ã®ã‚¹ã‚±ãƒ«ãƒˆãƒ³ã¨å½±ã§ä½ç½®ã‚’ç¢ºèª<br>
                ğŸš€ é€ŸãæŒ¯ã‚‹ã¨åŠ é€Ÿåº¦ãŒå¤§ãããªã‚Šå¼·ãæŠ•ã’ã‚‰ã‚Œã‚‹<br>
                âš–ï¸ å¤§ããªç‰©ä½“ã»ã©é‡ãã€æŠ•ã’ã«ãã„
            </div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Cannon.js ç‰©ç†ã‚¨ãƒ³ã‚¸ãƒ³ -->
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // MediaPipeè¨­å®š
        const videoElement = document.getElementById('videoElement');
        const canvasElement = document.getElementById('canvasElement');
        const canvasCtx = canvasElement.getContext('2d');
        const statusElement = document.getElementById('status');
        const objectCountElement = document.getElementById('objectCount');
        const physicsFPSElement = document.getElementById('physicsFPS');
        const handSpeedElement = document.getElementById('handSpeed');
        const handAccelElement = document.getElementById('handAccel');
        const removedCountElement = document.getElementById('removedCount');
        const rawZElement = document.getElementById('rawZ');
        
        // å‰Šé™¤ã‚«ã‚¦ãƒ³ã‚¿
        let removedObjectCount = 0;

        // Three.jsã‚·ãƒ¼ãƒ³è¨­å®š
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 15, 70);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 15);
        camera.lookAt(0, 3, 0);

        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('renderer'),
            antialias: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(8, 15, 8);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -30;
        directionalLight.shadow.camera.right = 30;
        directionalLight.shadow.camera.top = 30;
        directionalLight.shadow.camera.bottom = -30;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.bias = -0.0001;
        scene.add(directionalLight);

        // Cannon.jsç‰©ç†ä¸–ç•Œ
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);  // åœ°çƒã®é‡åŠ›
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;
        
        // æè³ªã®å®šç¾©ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ï¼‰
        const defaultMaterial = new CANNON.Material('default');
        const groundMaterial = new CANNON.Material('ground');
        
        // ç©ºæ°—æŠµæŠ—ã‚’è¿½åŠ ï¼ˆã‚ˆã‚Šè‡ªç„¶ãªæ¸›é€Ÿï¼‰
        world.defaultContactMaterial.friction = 0.4;
        world.defaultContactMaterial.restitution = 0.3;
        
        // æè³ªé–“ã®æ¥è§¦ç‰¹æ€§
        const groundContactMaterial = new CANNON.ContactMaterial(
            groundMaterial,
            defaultMaterial,
            {
                friction: 0.4,      // æ‘©æ“¦ä¿‚æ•°
                restitution: 0.3,   // åç™ºä¿‚æ•°ï¼ˆ0=å®Œå…¨éå¼¾æ€§ã€1=å®Œå…¨å¼¾æ€§ï¼‰
                contactEquationStiffness: 1e8,
                contactEquationRelaxation: 3
            }
        );
        world.addContactMaterial(groundContactMaterial);
        
        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåŒå£«ã®æ¥è§¦ç‰¹æ€§
        const objectContactMaterial = new CANNON.ContactMaterial(
            defaultMaterial,
            defaultMaterial,
            {
                friction: 0.3,
                restitution: 0.4,   // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåŒå£«ã¯å°‘ã—å¼¾ã‚€
                contactEquationStiffness: 1e8,
                contactEquationRelaxation: 3
            }
        );
        world.addContactMaterial(objectContactMaterial);

        // åœ°é¢
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ 
            mass: 0,
            material: groundMaterial
        });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        world.addBody(groundBody);

        const groundGeometry = new THREE.PlaneGeometry(60, 60);
        const groundMeshMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x3d8b3d,
            roughness: 0.8
        });
        const groundMesh = new THREE.Mesh(groundGeometry, groundMeshMaterial);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        // ç‰©ç†ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†
        const physicsObjects = [];

        // æ‰‹ã®ä½ç½®ã‚’ä¿æŒ
        let handPosition = null;
        let previousHandPosition = null;
        let handVelocity = new THREE.Vector3(0, 0, 0);
        let previousHandVelocity = new THREE.Vector3(0, 0, 0);
        let handAcceleration = new THREE.Vector3(0, 0, 0);
        let grabbedObject = null;
        let isPinching = false;
        let showSkeleton = true;

        // æ‰‹ã®ã‚¹ã‚±ãƒ«ãƒˆãƒ³ç”¨ã®ã‚°ãƒ«ãƒ¼ãƒ—
        const handSkeletonGroup = new THREE.Group();
        scene.add(handSkeletonGroup);

        // ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ç”¨ã®çƒä½“ï¼ˆ21å€‹ï¼‰
        const landmarkSpheres = [];
        for (let i = 0; i < 21; i++) {
            const geometry = new THREE.SphereGeometry(0.1, 16, 16);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x00ff00,
                transparent: true,
                opacity: 0.8,
                emissive: 0x00ff00,
                emissiveIntensity: 0.2
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.visible = false;
            sphere.castShadow = true; // å½±ã‚’è½ã¨ã™
            sphere.receiveShadow = true;
            handSkeletonGroup.add(sphere);
            landmarkSpheres.push(sphere);
        }

        // æ¥ç¶šç·šç”¨ã®ãƒãƒ†ãƒªã‚¢ãƒ«
        const lineMaterial = new THREE.LineBasicMaterial({ 
            color: 0x00ffff,
            linewidth: 2,
            transparent: true,
            opacity: 0.8
        });

        // MediaPipeã®æ‰‹ã®æ¥ç¶šå®šç¾©
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],           // è¦ªæŒ‡
            [0, 5], [5, 6], [6, 7], [7, 8],           // äººå·®ã—æŒ‡
            [0, 9], [9, 10], [10, 11], [11, 12],      // ä¸­æŒ‡
            [0, 13], [13, 14], [14, 15], [15, 16],    // è–¬æŒ‡
            [0, 17], [17, 18], [18, 19], [19, 20],    // å°æŒ‡
            [5, 9], [9, 13], [13, 17]                 // æ‰‹ã®ã²ã‚‰
        ];

        // æ¥ç¶šç·šã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        const connectionLines = [];
        HAND_CONNECTIONS.forEach(() => {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(6); // 2ç‚¹ Ã— 3åº§æ¨™
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const line = new THREE.Line(geometry, lineMaterial);
            line.visible = false;
            handSkeletonGroup.add(line);
            connectionLines.push(line);
        });

        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¿½åŠ é–¢æ•°
        function addBox() {
            const size = Math.random() * 0.5 + 0.5;
            const color = Math.random() * 0xffffff;

            // Three.js ãƒ¡ãƒƒã‚·ãƒ¥
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // ä½“ç©ãƒ™ãƒ¼ã‚¹ã®è³ªé‡è¨ˆç®—ï¼ˆæœ¨æã®å¯†åº¦: ç´„600 kg/mÂ³ï¼‰
            const volume = size * size * size;
            const density = 600;  // kg/mÂ³
            const mass = volume * density;

            // Cannon.js ãƒœãƒ‡ã‚£
            const shape = new CANNON.Box(new CANNON.Vec3(size / 2, size / 2, size / 2));
            const body = new CANNON.Body({ 
                mass: mass,
                shape: shape,
                material: defaultMaterial,
                position: new CANNON.Vec3(
                    Math.random() * 4 - 2,
                    5 + Math.random() * 3,
                    Math.random() * 4 - 2
                ),
                linearDamping: 0.1,   // ç©ºæ°—æŠµæŠ—ï¼ˆç·šå½¢æ¸›è¡°ï¼‰
                angularDamping: 0.1   // å›è»¢æŠµæŠ—ï¼ˆè§’æ¸›è¡°ï¼‰
            });
            world.addBody(body);

            physicsObjects.push({ mesh, body });
            updateObjectCount();
        }

        function addSphere() {
            const radius = Math.random() * 0.3 + 0.3;
            const color = Math.random() * 0xffffff;

            // Three.js ãƒ¡ãƒƒã‚·ãƒ¥
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // ä½“ç©ãƒ™ãƒ¼ã‚¹ã®è³ªé‡è¨ˆç®—ï¼ˆã‚´ãƒ ãƒœãƒ¼ãƒ«ã®å¯†åº¦: ç´„1000 kg/mÂ³ï¼‰
            const volume = (4 / 3) * Math.PI * radius * radius * radius;
            const density = 1000;  // kg/mÂ³
            const mass = volume * density;

            // Cannon.js ãƒœãƒ‡ã‚£
            const shape = new CANNON.Sphere(radius);
            const body = new CANNON.Body({ 
                mass: mass,
                shape: shape,
                material: defaultMaterial,
                position: new CANNON.Vec3(
                    Math.random() * 4 - 2,
                    5 + Math.random() * 3,
                    Math.random() * 4 - 2
                ),
                linearDamping: 0.05,   // çƒä½“ã¯ç©ºæ°—æŠµæŠ—ãŒå°‘ãªã„
                angularDamping: 0.05
            });
            world.addBody(body);

            physicsObjects.push({ mesh, body });
            updateObjectCount();
        }

        function resetScene() {
            physicsObjects.forEach(obj => {
                scene.remove(obj.mesh);
                world.removeBody(obj.body);
            });
            physicsObjects.length = 0;
            grabbedObject = null;
            removedObjectCount = 0;
            removedCountElement.textContent = '0';
            updateObjectCount();
        }

        function updateObjectCount() {
            objectCountElement.textContent = physicsObjects.length;
        }

        function toggleSkeletonDisplay() {
            showSkeleton = !showSkeleton;
            const btn = document.getElementById('toggleSkeleton');
            if (showSkeleton) {
                btn.classList.add('active');
                btn.textContent = 'ğŸ¦´ ã‚¹ã‚±ãƒ«ãƒˆãƒ³è¡¨ç¤º';
            } else {
                btn.classList.remove('active');
                btn.textContent = 'ğŸ¦´ ã‚¹ã‚±ãƒ«ãƒˆãƒ³éè¡¨ç¤º';
                // ã™ã¹ã¦éè¡¨ç¤º
                landmarkSpheres.forEach(sphere => sphere.visible = false);
                connectionLines.forEach(line => line.visible = false);
            }
        }

        // åˆæœŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¿½åŠ 
        for (let i = 0; i < 5; i++) {
            addBox();
            addSphere();
        }

        // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
        document.getElementById('addBox').addEventListener('click', addBox);
        document.getElementById('addSphere').addEventListener('click', addSphere);
        document.getElementById('reset').addEventListener('click', resetScene);
        document.getElementById('toggleSkeleton').addEventListener('click', toggleSkeletonDisplay);

        // MediaPipe Handsè¨­å®š
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // ã‚«ãƒ¡ãƒ©è¨­å®š
        const camera2 = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });
        camera2.start();

        function onResults(results) {
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusElement.textContent = 'æ¤œå‡ºä¸­';
                statusElement.className = 'status active';

                const landmarks = results.multiHandLandmarks[0];
                
                // æ‰‹ã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯æç”»
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 2 });
                drawLandmarks(canvasCtx, landmarks, { color: '#FF0000', lineWidth: 1 });

                // äººå·®ã—æŒ‡ã®å…ˆç«¯ï¼ˆãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯8ï¼‰
                const indexTip = landmarks[8];
                // è¦ªæŒ‡ã®å…ˆç«¯ï¼ˆãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯4ï¼‰
                const thumbTip = landmarks[4];
                
                // æ­£è¦åŒ–åº§æ¨™ã‚’3Dç©ºé–“åº§æ¨™ã«å¤‰æ›ï¼ˆå·¦å³åè»¢ï¼‰
                const x = -(indexTip.x - 0.5) * 15;  // ç¬¦å·ã‚’åè»¢
                const y = -(indexTip.y - 0.5) * 10 + 5;
                const z = indexTip.z * 10;  // ç¬¦å·åè»¢ï¼šã‚«ãƒ¡ãƒ©ã«è¿‘ã¥ãã¨å¥¥ã«è¡Œã

                previousHandPosition = handPosition ? handPosition.clone() : new THREE.Vector3(x, y, z);
                handPosition = new THREE.Vector3(x, y, z);

                // æ‰‹ã®é€Ÿåº¦è¨ˆç®— (ä½ç½®ã®å¤‰åŒ–ç‡)
                const currentVelocity = new THREE.Vector3(0, 0, 0);
                if (previousHandPosition) {
                    currentVelocity.copy(handPosition).sub(previousHandPosition).multiplyScalar(60);
                }

                // æ‰‹ã®åŠ é€Ÿåº¦è¨ˆç®— (é€Ÿåº¦ã®å¤‰åŒ–ç‡)
                handAcceleration.copy(currentVelocity).sub(previousHandVelocity).multiplyScalar(60);
                
                // é€Ÿåº¦ã‚’æ›´æ–°
                previousHandVelocity.copy(handVelocity);
                handVelocity.copy(currentVelocity);

                // é€Ÿåº¦ã¨åŠ é€Ÿåº¦ã‚’è¡¨ç¤º
                const speed = handVelocity.length();
                const accel = handAcceleration.length();
                handSpeedElement.textContent = speed.toFixed(1);
                handAccelElement.textContent = accel.toFixed(1);
                rawZElement.textContent = indexTip.z.toFixed(4);  // ç”Ÿã®zå€¤ã‚’è¡¨ç¤º

                // æ‰‹ã®ã‚¹ã‚±ãƒ«ãƒˆãƒ³è¡¨ç¤º
                if (showSkeleton) {
                    // å„ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã®3Dä½ç½®ã‚’æ›´æ–°
                    landmarks.forEach((landmark, index) => {
                        const lx = -(landmark.x - 0.5) * 15;  // å·¦å³åè»¢
                        const ly = -(landmark.y - 0.5) * 10 + 5;
                        const lz = landmark.z * 10;  // ç¬¦å·åè»¢
                        
                        landmarkSpheres[index].position.set(lx, ly, lz);
                        landmarkSpheres[index].visible = true;
                        
                        // ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã®ç¨®é¡ã«ã‚ˆã£ã¦è‰²ã‚’å¤‰ãˆã‚‹
                        if (index === 0) {
                            // æ‰‹é¦–
                            landmarkSpheres[index].material.color.setHex(0xff0000);
                            landmarkSpheres[index].material.emissive.setHex(0xff0000);
                        } else if (index === 4 || index === 8 || index === 12 || index === 16 || index === 20) {
                            // æŒ‡å…ˆ
                            landmarkSpheres[index].material.color.setHex(0xffff00);
                            landmarkSpheres[index].material.emissive.setHex(0xffff00);
                        } else {
                            // ãã®ä»–
                            landmarkSpheres[index].material.color.setHex(0x00ff00);
                            landmarkSpheres[index].material.emissive.setHex(0x00ff00);
                        }
                    });

                    // æ¥ç¶šç·šã‚’æ›´æ–°
                    HAND_CONNECTIONS.forEach((connection, index) => {
                        const [start, end] = connection;
                        const startPos = landmarkSpheres[start].position;
                        const endPos = landmarkSpheres[end].position;
                        
                        const positions = connectionLines[index].geometry.attributes.position.array;
                        positions[0] = startPos.x;
                        positions[1] = startPos.y;
                        positions[2] = startPos.z;
                        positions[3] = endPos.x;
                        positions[4] = endPos.y;
                        positions[5] = endPos.z;
                        
                        connectionLines[index].geometry.attributes.position.needsUpdate = true;
                        connectionLines[index].visible = true;
                    });
                } else {
                    landmarkSpheres.forEach(sphere => sphere.visible = false);
                    connectionLines.forEach(line => line.visible = false);
                }

                // ãƒ”ãƒ³ãƒæ¤œå‡ºï¼ˆè¦ªæŒ‡ã¨äººå·®ã—æŒ‡ã®è·é›¢ï¼‰
                const pinchDistance = Math.sqrt(
                    Math.pow(indexTip.x - thumbTip.x, 2) +
                    Math.pow(indexTip.y - thumbTip.y, 2) +
                    Math.pow(indexTip.z - thumbTip.z, 2)
                );

                const wasPinching = isPinching;
                isPinching = pinchDistance < 0.05;

                // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã¤ã‹ã‚€
                if (isPinching && !wasPinching && !grabbedObject) {
                    // æœ€ã‚‚è¿‘ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¢ã™
                    let closestObject = null;
                    let closestDistance = Infinity;

                    physicsObjects.forEach(obj => {
                        const objPos = new THREE.Vector3(
                            obj.body.position.x,
                            obj.body.position.y,
                            obj.body.position.z
                        );
                        const distance = handPosition.distanceTo(objPos);
                        if (distance < closestDistance && distance < 2) {
                            closestDistance = distance;
                            closestObject = obj;
                        }
                    });

                    if (closestObject) {
                        grabbedObject = closestObject;
                        // å…ƒã®è³ªé‡ã‚’ä¿å­˜ã—ã¦ã‹ã‚‰é‡åŠ›ã‚’ç„¡åŠ¹åŒ–
                        grabbedObject.originalMass = grabbedObject.body.mass;
                        grabbedObject.body.mass = 0;
                        grabbedObject.body.updateMassProperties();
                    }
                }

                // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒã¡ä¸Šã’ã‚‹
                if (grabbedObject && isPinching) {
                    grabbedObject.body.position.set(handPosition.x, handPosition.y, handPosition.z);
                    grabbedObject.body.velocity.set(0, 0, 0);
                    grabbedObject.body.angularVelocity.set(0, 0, 0);
                }

                // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ”¾ã™
                if (!isPinching && wasPinching && grabbedObject) {
                    // å…ƒã®è³ªé‡ã‚’å¾©å…ƒ
                    grabbedObject.body.mass = grabbedObject.originalMass || 1;
                    grabbedObject.body.updateMassProperties();
                    
                    // é€Ÿåº¦ã¨åŠ é€Ÿåº¦ã‚’çµ„ã¿åˆã‚ã›ã¦æŠ•ã’ã‚‹åŠ›ã‚’è¨ˆç®—
                    // ä¿‚æ•°ã‚’å°ã•ãã—ã¦æŠ•ã’ã‚‹åŠ›ã‚’æŠ‘ãˆã‚‹
                    const throwVelocity = new THREE.Vector3(
                        handVelocity.x + handAcceleration.x * 0.008,
                        handVelocity.y + handAcceleration.y * 0.008,
                        handVelocity.z + handAcceleration.z * 0.008
                    );
                    
                    // é€Ÿåº¦ä¿‚æ•°ã‚’0.25â†’0.3ã«å¾®èª¿æ•´ï¼ˆè³ªé‡ãŒå¤§ãããªã£ãŸãŸã‚ï¼‰
                    grabbedObject.body.velocity.set(
                        throwVelocity.x * 0.3,
                        throwVelocity.y * 0.3,
                        throwVelocity.z * 0.3
                    );
                    
                    // å›è»¢ã‚‚å°‘ã—æŠ‘ãˆã‚‹
                    const spinFactor = 0.05;
                    grabbedObject.body.angularVelocity.set(
                        handAcceleration.y * spinFactor,
                        -handAcceleration.x * spinFactor,
                        handAcceleration.z * spinFactor
                    );
                    
                    grabbedObject = null;
                }

            } else {
                statusElement.textContent = 'æœªæ¤œå‡º';
                statusElement.className = 'status inactive';
                handPosition = null;
                
                // é€Ÿåº¦ã¨åŠ é€Ÿåº¦è¡¨ç¤ºã‚’ãƒªã‚»ãƒƒãƒˆ
                handSpeedElement.textContent = '0.0';
                handAccelElement.textContent = '0.0';
                rawZElement.textContent = '0.0';
                
                // ã‚¹ã‚±ãƒ«ãƒˆãƒ³ã‚’éè¡¨ç¤º
                landmarkSpheres.forEach(sphere => sphere.visible = false);
                connectionLines.forEach(line => line.visible = false);
                
                if (grabbedObject) {
                    grabbedObject.body.mass = grabbedObject.originalMass || 1;
                    grabbedObject.body.updateMassProperties();
                    grabbedObject = null;
                }
            }

            canvasCtx.restore();
        }

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        const timeStep = 1 / 60;
        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // ç‰©ç†ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
            world.step(timeStep);

            // ç‰©ç†ãƒœãƒ‡ã‚£ã¨ãƒ¡ãƒƒã‚·ãƒ¥ã‚’åŒæœŸ & è½ä¸‹ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤
            for (let i = physicsObjects.length - 1; i >= 0; i--) {
                const obj = physicsObjects[i];
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
                
                // åœ°é¢ã‚ˆã‚Šä¸‹ã«è½ã¡ãŸã‚‰å‰Šé™¤ï¼ˆy < -10ï¼‰
                if (obj.body.position.y < -10) {
                    scene.remove(obj.mesh);
                    world.removeBody(obj.body);
                    physicsObjects.splice(i, 1);
                    
                    // å‰Šé™¤ã‚«ã‚¦ãƒ³ã‚¿ã‚’å¢—ã‚„ã™
                    removedObjectCount++;
                    removedCountElement.textContent = removedObjectCount;
                    
                    // ã¤ã‹ã‚“ã§ã„ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‰Šé™¤ã•ã‚ŒãŸå ´åˆ
                    if (grabbedObject === obj) {
                        grabbedObject = null;
                    }
                    
                    // ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯é˜²æ­¢ã®ãŸã‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                    delete obj.originalMass;
                }
            }
            
            // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°ã‚’æ›´æ–°
            updateObjectCount();

            // FPSè¡¨ç¤º
            physicsFPSElement.textContent = Math.round(1 / deltaTime);

            renderer.render(scene, camera);
        }

        animate();

        // ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>