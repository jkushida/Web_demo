<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaPipe + 3D Physics Engine Demo (Mirror Mode)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #videoElement {
            /* ã‚«ãƒ¡ãƒ©ç”»åƒã¯è¡¨ç¤ºã—ãªã„ */
            display: none;
        }
        
        #canvasElement {
            /* å³ä¸Šã®2Dã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆæ‰‹ã®æç”»ï¼‰ã¯ä¸è¦ã®ãŸã‚éè¡¨ç¤º */
            display: none;
        }
        
        #output {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 10;
            max-width: 350px;
        }
        
        h1 {
            font-size: 24px;
            margin-bottom: 15px;
            color: #667eea;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        
        .info {
            margin: 10px 0;
            font-size: 14px;
            line-height: 1.6;
            color: #333;
        }
        
        .status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            margin-top: 10px;
        }
        
        .status.active {
            background: #4ade80;
            color: white;
        }
        
        .status.inactive {
            background: #f87171;
            color: white;
        }
        
        .controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        button.active {
            background: #4ade80;
        }
        
        #renderer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .instruction {
            background: #fef3c7;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 13px;
            color: #92400e;
            border-left: 4px solid #fbbf24;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="renderer"></canvas>
        <video id="videoElement" autoplay playsinline></video>
        <canvas id="canvasElement"></canvas>
        
        <div id="output">
            <h1>ğŸ® 3D Physics Ã— MediaPipe</h1>
            <div class="info">
                <strong>æ¤œå‡ºçŠ¶æ…‹:</strong> <span class="status inactive" id="status">æœªæ¤œå‡º</span>
            </div>
            <div class="info">
                <strong>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°:</strong> <span id="objectCount">0</span>
            </div>
            <div class="info">
                <strong>å‰Šé™¤æ•°:</strong> <span id="removedCount">0</span>
            </div>
            <div class="info">
                <strong>ç‰©ç†æ¼”ç®—FPS:</strong> <span id="physicsFPS">0</span>
            </div>
            <div class="info">
                <strong>æ‰‹ã®é€Ÿåº¦:</strong> <span id="handSpeed">0.0</span> m/s
            </div>
            <div class="info">
                <strong>åŠ é€Ÿåº¦:</strong> <span id="handAccel">0.0</span> m/sÂ²
            </div>
            <div class="info" style="background: #ffe4e6; padding: 5px; border-radius: 3px;">
                <strong>MediaPipeç”ŸZå€¤:</strong> <span id="rawZ">0.0</span>
            </div>
            <div class="controls">
                <button id="addBox">ğŸ“¦ ç®±ã‚’è¿½åŠ </button>
                <button id="addSphere">âš½ çƒã‚’è¿½åŠ </button>
                <button id="reset">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
            <div class="instruction">
                <strong>ğŸ’¡ ä½¿ã„æ–¹:</strong><br>
                âœ‹ ã‚«ãƒ¡ãƒ©ã«æ‰‹ã®ã²ã‚‰ã‚’å‘ã‘ã‚‹ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ˜ åƒã¯è¡¨ç¤ºã•ã‚Œã¾ã›ã‚“ï¼‰<br>
                ğŸ“ ã‚«ãƒ¡ãƒ©ã«æ‰‹ã‚’è¿‘ã¥ã‘ã‚‹ã¨3Dç©ºé–“ã§æ‰‹å‰ã«ç§»å‹•ã—ã¾ã™<br>
                ğŸ‘† äººå·®ã—æŒ‡ã¨è¦ªæŒ‡ã§ã¤ã¾ã‚“ã§ç‰©ä½“ã‚’ã¤ã‹ã‚€<br>
                ğŸ–ï¸ æ‰‹ã‚’é–‹ã„ã¦ç‰©ä½“ã‚’æŠ•ã’ã‚‹<br>
                ğŸ¦´ æ‰‹ã®ã‚¹ã‚±ãƒ«ãƒˆãƒ³ã¨å½±ã§ä½ç½®ã‚’ç¢ºèª<br>
                ğŸš€ é€ŸãæŒ¯ã‚‹ã¨åŠ é€Ÿåº¦ãŒå¤§ãããªã‚Šå¼·ãæŠ•ã’ã‚‰ã‚Œã‚‹<br>
                âš–ï¸ å¤§ããªç‰©ä½“ã»ã©é‡ãã€æŠ•ã’ã«ãã„
            </div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Cannon.js ç‰©ç†ã‚¨ãƒ³ã‚¸ãƒ³ -->
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // MediaPipeè¨­å®š
        const videoElement = document.getElementById('videoElement');
        const canvasElement = document.getElementById('canvasElement');
        const canvasCtx = canvasElement.getContext('2d');
        const statusElement = document.getElementById('status');
        const objectCountElement = document.getElementById('objectCount');
        const physicsFPSElement = document.getElementById('physicsFPS');
        const handSpeedElement = document.getElementById('handSpeed');
        const handAccelElement = document.getElementById('handAccel');
        const removedCountElement = document.getElementById('removedCount');
        const rawZElement = document.getElementById('rawZ');
        
        // å‰Šé™¤ã‚«ã‚¦ãƒ³ã‚¿
        let removedObjectCount = 0;

        // Three.jsã‚·ãƒ¼ãƒ³è¨­å®š
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 15, 70);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 15);
        camera.lookAt(0, 3, 0);

        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('renderer'),
            antialias: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(8, 15, 8);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -30;
        directionalLight.shadow.camera.right = 30;
        directionalLight.shadow.camera.top = 30;
        directionalLight.shadow.camera.bottom = -30;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.bias = -0.0001;
        scene.add(directionalLight);

        // Cannon.jsç‰©ç†ä¸–ç•Œ
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);  // åœ°çƒã®é‡åŠ›
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;
        
        // æè³ªã®å®šç¾©ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ï¼‰
        const defaultMaterial = new CANNON.Material('default');
        const groundMaterial = new CANNON.Material('ground');
        
        // ç©ºæ°—æŠµæŠ—ã‚’è¿½åŠ ï¼ˆã‚ˆã‚Šè‡ªç„¶ãªæ¸›é€Ÿï¼‰
        world.defaultContactMaterial.friction = 0.4;
        world.defaultContactMaterial.restitution = 0.3;
        
        // æè³ªé–“ã®æ¥è§¦ç‰¹æ€§
        const groundContactMaterial = new CANNON.ContactMaterial(
            groundMaterial,
            defaultMaterial,
            {
                friction: 0.4,      // æ‘©æ“¦ä¿‚æ•°
                restitution: 0.3,   // åç™ºä¿‚æ•°ï¼ˆ0=å®Œå…¨éå¼¾æ€§ã€1=å®Œå…¨å¼¾æ€§ï¼‰
                contactEquationStiffness: 1e8,
                contactEquationRelaxation: 3
            }
        );
        world.addContactMaterial(groundContactMaterial);
        
        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåŒå£«ã®æ¥è§¦ç‰¹æ€§
        const objectContactMaterial = new CANNON.ContactMaterial(
            defaultMaterial,
            defaultMaterial,
            {
                friction: 0.3,
                restitution: 0.4,   // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåŒå£«ã¯å°‘ã—å¼¾ã‚€
                contactEquationStiffness: 1e8,
                contactEquationRelaxation: 3
            }
        );
        world.addContactMaterial(objectContactMaterial);

        // åœ°é¢
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ 
            mass: 0,
            material: groundMaterial
        });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        world.addBody(groundBody);

        const groundGeometry = new THREE.PlaneGeometry(60, 60);
        const groundMeshMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x3d8b3d,
            roughness: 0.8
        });
        const groundMesh = new THREE.Mesh(groundGeometry, groundMeshMaterial);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å¢ƒç•Œï¼ˆåœ°é¢ã‚µã‚¤ã‚ºã«åŸºã¥ãå‰Šé™¤åˆ¤å®šï¼‰
        const FIELD_HALF_SIZE = 30;   // groundGeometryã®åŠã‚µã‚¤ã‚º
        const FIELD_MARGIN = 10;      // ç”»é¢å¤–ã«å‡ºã¦ã‹ã‚‰æ¶ˆã™ä½™ç™½
        const FIELD_MIN_Y = -10;      // è½ä¸‹ã§å‰Šé™¤
        const FIELD_MAX_Y = 50;       // é«˜ã™ãã‚‹å ´åˆã‚‚å‰Šé™¤

        // ç‰©ç†ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†
        const physicsObjects = [];

        // æ‰‹ã®ä½ç½®ã‚’ä¿æŒ
        let handPosition = null;
        let previousHandPosition = null;
        let handVelocity = new THREE.Vector3(0, 0, 0);
        let previousHandVelocity = new THREE.Vector3(0, 0, 0);
        let handAcceleration = new THREE.Vector3(0, 0, 0);
        let grabbedObject = null;
        let isPinching = false;
        let showSkeleton = true;

        // æ“ä½œæ„Ÿå‘ä¸Šã®ãŸã‚ã®å¹³æ»‘åŒ–ãƒ»ã—ãã„å€¤
        let filteredHandPosition = null;
        let filteredHandVelocity = new THREE.Vector3(0, 0, 0);
        let previousFilteredVelocity = new THREE.Vector3(0, 0, 0);
        let filteredHandAcceleration = new THREE.Vector3(0, 0, 0);
        const POS_SMOOTH_XY = 0.25; // XYã®å¹³æ»‘åŒ–ä¿‚æ•°ï¼ˆ0â€¦ä¿æŒ/1â€¦å³æ™‚ï¼‰
        const POS_SMOOTH_Z  = 0.40; // Zã¯ã‚„ã‚„å¿œç­”æ€§ã‚’ä¸Šã’ã‚‹
        const VEL_SMOOTH = 0.3;    // æ‰‹é€Ÿåº¦ã®å¹³æ»‘åŒ–ä¿‚æ•°
        const PINCH_ON = 0.045;    // ãƒ”ãƒ³ãƒé–‹å§‹ã—ãã„å€¤ï¼ˆãƒ’ã‚¹ãƒ†ãƒªã‚·ã‚¹ï¼‰
        const PINCH_OFF = 0.055;   // ãƒ”ãƒ³ãƒçµ‚äº†ã—ãã„å€¤
        const GRAB_DISTANCE = 2.5; // æ´ã¿å¯¾è±¡ã®æ¢ç´¢è·é›¢ï¼ˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ‹¡å¤§ã«åˆã‚ã›ã¦å°‘ã—åºƒã‚ï¼‰
        const FOLLOW_LERP = 0.35;  // æ´ã¿ä¸­ã«æ‰‹ã¸è¿½å¾“ã•ã›ã‚‹ä½ç½®è£œé–“ä¿‚æ•°ï¼ˆäº’æ›ç¶­æŒï¼‰
        const FOLLOW_LERP_NEAR = 0.6; // è¿‘è·é›¢æ™‚ã®è¿½å¾“ä¿‚æ•°ï¼ˆé€Ÿã‚ï¼‰
        const FOLLOW_LERP_FAR  = 0.9; // é è·é›¢æ™‚ã®è¿½å¾“ä¿‚æ•°ï¼ˆã•ã‚‰ã«é€Ÿã‚ï¼‰
        const SNAP_DISTANCE    = 0.75; // ã“ã®è·é›¢ã‚’è¶…ãˆãŸã‚‰ã‚¹ãƒŠãƒƒãƒ—
        const GRAB_COOLDOWN_MS = 200; // é›¢ã—ãŸç›´å¾Œã«å†åº¦æ´ã¾ãªã„ãŸã‚ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
        let lastReleaseTime = 0;
        const DROP_SPEED_THRESHOLD = 1.0; // ã“ã®é€Ÿåº¦æœªæº€ãªã‚‰çœŸä¸‹ã«è½ã¨ã™ï¼ˆæŠ•ã’ãªã„ï¼‰

        // æ‰‹å‰ã«æ¥ã‚‹ã»ã©ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã‚’å°‘ã—å¤§ããè¦‹ã›ã‚‹
        const DEPTH_SIZE_GAIN = 0.06; // Zã«å¯¾ã™ã‚‹å¢—åŠ ç‡ï¼ˆæ§ãˆã‚ï¼‰
        const DEPTH_SIZE_MIN = 0.9;   // ç¸®å°ä¸‹é™
        const DEPTH_SIZE_MAX = 1.4;   // æ‹¡å¤§ä¸Šé™

        // Zæ–¹å‘ã®å¯å‹•åŸŸã‚’æ‹¡å¤§ï¼ˆMediaPipeã®zã¯å€¤å¹…ãŒå°ã•ã„ãŸã‚ã‚¹ã‚±ãƒ¼ãƒ«ï¼‰
        const Z_SCALE = 35; // æ—¢å­˜10â†’35ã¸æ‹¡å¤§ï¼ˆå¿…è¦ã«å¿œã˜ã¦å†èª¿æ•´ï¼‰

        // æ‰‹ã®ã‚¹ã‚±ãƒ«ãƒˆãƒ³ç”¨ã®ã‚°ãƒ«ãƒ¼ãƒ—
        const handSkeletonGroup = new THREE.Group();
        scene.add(handSkeletonGroup);

        // ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ç”¨ã®çƒä½“ï¼ˆ21å€‹ï¼‰
        const landmarkSpheres = [];
        for (let i = 0; i < 21; i++) {
            // æ‰‹é¦–ï¼ˆindex 0ï¼‰ã¯å°‘ã—å¤§ãã‚ã«ã—ã¦å½±ã‚’å¼·èª¿
            const radius = (i === 0) ? 0.16 : 0.1;
            const geometry = new THREE.SphereGeometry(radius, 16, 16);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x00ff00,
                transparent: true,
                opacity: 0.8,
                emissive: 0x00ff00,
                emissiveIntensity: 0.2
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.visible = false;
            sphere.castShadow = true; // å½±ã‚’è½ã¨ã™
            sphere.receiveShadow = true;
            handSkeletonGroup.add(sphere);
            landmarkSpheres.push(sphere);
        }

        // æ¥ç¶šç·šç”¨ã®ãƒãƒ†ãƒªã‚¢ãƒ«
        const lineMaterial = new THREE.LineBasicMaterial({ 
            color: 0x00ffff,
            linewidth: 2,
            transparent: true,
            opacity: 0.8
        });

        // MediaPipeã®æ‰‹ã®æ¥ç¶šå®šç¾©
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],           // è¦ªæŒ‡
            [0, 5], [5, 6], [6, 7], [7, 8],           // äººå·®ã—æŒ‡
            [0, 9], [9, 10], [10, 11], [11, 12],      // ä¸­æŒ‡
            [0, 13], [13, 14], [14, 15], [15, 16],    // è–¬æŒ‡
            [0, 17], [17, 18], [18, 19], [19, 20],    // å°æŒ‡
            [5, 9], [9, 13], [13, 17]                 // æ‰‹ã®ã²ã‚‰
        ];

        // æ¥ç¶šç·šã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        const connectionLines = [];
        HAND_CONNECTIONS.forEach(() => {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(6); // 2ç‚¹ Ã— 3åº§æ¨™
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const line = new THREE.Line(geometry, lineMaterial);
            line.visible = false;
            handSkeletonGroup.add(line);
            connectionLines.push(line);
        });

        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¿½åŠ é–¢æ•°
        function addBox(opts = {}) {
            // ä»¥å‰: 0.5ã€œ1.0 â†’ å°‘ã—å¤§ãã‚ã«: 1.0ã€œ2.0
            const size = Math.random() * 1.0 + 1.0;
            const color = Math.random() * 0xffffff;

            // Three.js ãƒ¡ãƒƒã‚·ãƒ¥
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // ä½“ç©ãƒ™ãƒ¼ã‚¹ã®è³ªé‡è¨ˆç®—ï¼ˆæœ¨æã®å¯†åº¦: ç´„600 kg/mÂ³ï¼‰
            const volume = size * size * size;
            const density = 600;  // kg/mÂ³
            const mass = volume * density;

            // Cannon.js ãƒœãƒ‡ã‚£
            const shape = new CANNON.Box(new CANNON.Vec3(size / 2, size / 2, size / 2));
            const body = new CANNON.Body({ 
                mass: mass,
                shape: shape,
                material: defaultMaterial,
                position: new CANNON.Vec3(
                    (opts.position && typeof opts.position.x === 'number') ? opts.position.x : (Math.random() * 4 - 2),
                    (opts.position && typeof opts.position.y === 'number') ? opts.position.y : (5 + Math.random() * 3),
                    (opts.position && typeof opts.position.z === 'number') ? opts.position.z : (Math.random() * 4 - 2)
                ),
                linearDamping: 0.1,   // ç©ºæ°—æŠµæŠ—ï¼ˆç·šå½¢æ¸›è¡°ï¼‰
                angularDamping: 0.1   // å›è»¢æŠµæŠ—ï¼ˆè§’æ¸›è¡°ï¼‰
            });
            // å®‰å®šåŒ–ï¼ˆé™æ­¢ã—ã‚„ã™ãï¼‰
            body.allowSleep = true;
            body.sleepSpeedLimit = 0.1;   // é€Ÿåº¦ãŒã“ã®å€¤æœªæº€ã§
            body.sleepTimeLimit = 0.5;    // æŒ‡å®šæ™‚é–“çµŒéã§ã‚¹ãƒªãƒ¼ãƒ—
            world.addBody(body);

            physicsObjects.push({ mesh, body });
            updateObjectCount();
        }

        function addSphere(opts = {}) {
            // ä»¥å‰: 0.3ã€œ0.6 â†’ å°‘ã—å¤§ãã‚ã«: 0.5ã€œ1.0
            const radius = Math.random() * 0.5 + 0.5;
            const color = Math.random() * 0xffffff;

            // Three.js ãƒ¡ãƒƒã‚·ãƒ¥
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // ä½“ç©ãƒ™ãƒ¼ã‚¹ã®è³ªé‡è¨ˆç®—ï¼ˆã‚´ãƒ ãƒœãƒ¼ãƒ«ã®å¯†åº¦: ç´„1000 kg/mÂ³ï¼‰
            const volume = (4 / 3) * Math.PI * radius * radius * radius;
            const density = 1000;  // kg/mÂ³
            const mass = volume * density;

            // Cannon.js ãƒœãƒ‡ã‚£
            const shape = new CANNON.Sphere(radius);
            const body = new CANNON.Body({ 
                mass: mass,
                shape: shape,
                material: defaultMaterial,
                position: new CANNON.Vec3(
                    (opts.position && typeof opts.position.x === 'number') ? opts.position.x : (Math.random() * 4 - 2),
                    (opts.position && typeof opts.position.y === 'number') ? opts.position.y : (5 + Math.random() * 3),
                    (opts.position && typeof opts.position.z === 'number') ? opts.position.z : (Math.random() * 4 - 2)
                ),
                linearDamping: 0.05,   // çƒä½“ã¯ç©ºæ°—æŠµæŠ—ãŒå°‘ãªã„
                angularDamping: 0.05
            });
            // å®‰å®šåŒ–ï¼ˆé™æ­¢ã—ã‚„ã™ãï¼‰
            body.allowSleep = true;
            body.sleepSpeedLimit = 0.1;
            body.sleepTimeLimit = 0.5;
            world.addBody(body);

            physicsObjects.push({ mesh, body });
            updateObjectCount();
        }

        function resetScene() {
            physicsObjects.forEach(obj => {
                scene.remove(obj.mesh);
                world.removeBody(obj.body);
            });
            physicsObjects.length = 0;
            grabbedObject = null;
            removedObjectCount = 0;
            removedCountElement.textContent = '0';
            updateObjectCount();
        }

        function updateObjectCount() {
            objectCountElement.textContent = physicsObjects.length;
        }

        

        // åˆæœŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä½ã„é«˜ã•ãƒ»æ•´åˆ—é…ç½®ã§é‡ãªã‚Šã¨è·³ã­ã‚’æŠ‘åˆ¶
        function addInitialObjects() {
            const positions = [];
            const cols = 4; // æ¨ªæ–¹å‘é…ç½®æ•°
            const spacing = 3.5; // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æœ€å¤§ã‚µã‚¤ã‚ºã‚’è€ƒæ…®ã—ãŸé–“éš”
            const rows = 3; // ç¸¦æ–¹å‘é…ç½®æ•°
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    positions.push({
                        x: (c - (cols - 1) / 2) * spacing,
                        y: 1.2, // ä½ã„é«˜ã•ã‹ã‚‰é–‹å§‹ã—ã€è·³ã­ã‚’æŠ‘åˆ¶
                        z: (r - (rows - 1) / 2) * spacing
                    });
                }
            }
            // å¿…è¦æ•°ã ã‘åˆ©ç”¨ï¼ˆå¾“æ¥ã¨åŒæ•°: 10å€‹ = ç®±5 + çƒ5ï¼‰
            for (let i = 0; i < 5; i++) {
                const p1 = positions[i % positions.length];
                const p2 = positions[(i + 6) % positions.length]; // å°‘ã—é›¢ã‚ŒãŸåˆ¥åº§æ¨™
                addBox({ position: p1 });
                addSphere({ position: p2 });
            }
        }
        addInitialObjects();

        // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
        document.getElementById('addBox').addEventListener('click', addBox);
        document.getElementById('addSphere').addEventListener('click', addSphere);
        document.getElementById('reset').addEventListener('click', resetScene);

        // MediaPipe Handsè¨­å®š
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // ã‚«ãƒ¡ãƒ©è¨­å®š
        const camera2 = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });
        camera2.start();

        function onResults(results) {
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusElement.textContent = 'æ¤œå‡ºä¸­';
                statusElement.className = 'status active';

                const landmarks = results.multiHandLandmarks[0];
                
                // æ‰‹ã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯æç”»
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 2 });
                drawLandmarks(canvasCtx, landmarks, { color: '#FF0000', lineWidth: 1 });

                // äººå·®ã—æŒ‡ã®å…ˆç«¯ï¼ˆãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯8ï¼‰
                const indexTip = landmarks[8];
                // è¦ªæŒ‡ã®å…ˆç«¯ï¼ˆãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯4ï¼‰
                const thumbTip = landmarks[4];
                
                // æ­£è¦åŒ–åº§æ¨™ã‚’3Dç©ºé–“åº§æ¨™ã«å¤‰æ›ï¼ˆå·¦å³åè»¢ï¼‰
                const x = -(indexTip.x - 0.5) * 15;  // ç¬¦å·ã‚’åè»¢
                const y = -(indexTip.y - 0.5) * 10 + 5;
                const z = -indexTip.z * Z_SCALE;  // Zã‚¹ã‚±ãƒ¼ãƒ«æ‹¡å¤§ï¼šè¿‘ã¥ãã»ã©æ‰‹å‰ã«å‹•ãã‚„ã™ã

                previousHandPosition = handPosition ? handPosition.clone() : new THREE.Vector3(x, y, z);
                handPosition = new THREE.Vector3(x, y, z);

                // æ‰‹ä½ç½®ãƒ»é€Ÿåº¦ã‚’å¹³æ»‘åŒ–
                if (!filteredHandPosition) {
                    filteredHandPosition = handPosition.clone();
                } else {
                    // æˆåˆ†ã”ã¨ã«å¹³æ»‘åŒ–ä¿‚æ•°ã‚’èª¿æ•´ï¼ˆZã¯å¿œç­”æ€§é«˜ã‚ï¼‰
                    filteredHandPosition.x += (handPosition.x - filteredHandPosition.x) * POS_SMOOTH_XY;
                    filteredHandPosition.y += (handPosition.y - filteredHandPosition.y) * POS_SMOOTH_XY;
                    filteredHandPosition.z += (handPosition.z - filteredHandPosition.z) * POS_SMOOTH_Z;
                }

                // æ‰‹ã®é€Ÿåº¦è¨ˆç®— (ä½ç½®ã®å¤‰åŒ–ç‡)
                const currentVelocity = new THREE.Vector3(0, 0, 0);
                if (previousHandPosition) {
                    currentVelocity.copy(handPosition).sub(previousHandPosition).multiplyScalar(60);
                }

                // æ‰‹ã®åŠ é€Ÿåº¦è¨ˆç®— (é€Ÿåº¦ã®å¤‰åŒ–ç‡)
                handAcceleration.copy(currentVelocity).sub(previousHandVelocity).multiplyScalar(60);
                
                // é€Ÿåº¦ã‚’æ›´æ–°ï¼ˆç”Ÿå€¤ï¼‰
                previousHandVelocity.copy(handVelocity);
                handVelocity.copy(currentVelocity);

                // å¹³æ»‘åŒ–ã—ãŸé€Ÿåº¦ãƒ»åŠ é€Ÿåº¦
                previousFilteredVelocity.copy(filteredHandVelocity);
                filteredHandVelocity.lerp(currentVelocity, VEL_SMOOTH);
                filteredHandAcceleration.copy(filteredHandVelocity).sub(previousFilteredVelocity).multiplyScalar(60);

                // é€Ÿåº¦ã¨åŠ é€Ÿåº¦ã‚’è¡¨ç¤º
                const speed = filteredHandVelocity.length();
                const accel = filteredHandAcceleration.length();
                handSpeedElement.textContent = speed.toFixed(1);
                handAccelElement.textContent = accel.toFixed(1);
                rawZElement.textContent = indexTip.z.toFixed(4);  // ç”Ÿã®zå€¤ã‚’è¡¨ç¤º

                // æ‰‹ã®ã‚¹ã‚±ãƒ«ãƒˆãƒ³è¡¨ç¤º
                if (showSkeleton) {
                    // å„ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã®3Dä½ç½®ã‚’æ›´æ–°
                    landmarks.forEach((landmark, index) => {
                        const lx = -(landmark.x - 0.5) * 15;  // å·¦å³åè»¢
                        const ly = -(landmark.y - 0.5) * 10 + 5;
                        const lz = -landmark.z * Z_SCALE;  // ç¬¦å·åè»¢ï¼ˆè¿‘ã¥ãã»ã©æ‰‹å‰ï¼‰
                        
                        const sphere = landmarkSpheres[index];
                        sphere.position.set(lx, ly, lz);
                        sphere.visible = true;
                        // æ‰‹å‰ã«æ¥ã‚‹ã»ã©å°‘ã—å¤§ããï¼ˆZã«æ¯”ä¾‹ã€ä¸Šé™ãƒ»ä¸‹é™ã§ã‚¯ãƒ©ãƒ³ãƒ—ï¼‰
                        const depthScale = Math.min(DEPTH_SIZE_MAX, Math.max(DEPTH_SIZE_MIN, 1 + DEPTH_SIZE_GAIN * lz));
                        sphere.scale.set(depthScale, depthScale, depthScale);
                        
                        // ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã®ç¨®é¡ã«ã‚ˆã£ã¦è‰²ã‚’å¤‰ãˆã‚‹
                        if (index === 0) {
                            // æ‰‹é¦–
                            sphere.material.color.setHex(0xff0000);
                            sphere.material.emissive.setHex(0xff0000);
                        } else if (index === 4 || index === 8 || index === 12 || index === 16 || index === 20) {
                            // æŒ‡å…ˆ
                            sphere.material.color.setHex(0xffff00);
                            sphere.material.emissive.setHex(0xffff00);
                        } else {
                            // ãã®ä»–
                            sphere.material.color.setHex(0x00ff00);
                            sphere.material.emissive.setHex(0x00ff00);
                        }
                    });

                    // æ¥ç¶šç·šã‚’æ›´æ–°
                    HAND_CONNECTIONS.forEach((connection, index) => {
                        const [start, end] = connection;
                        const startPos = landmarkSpheres[start].position;
                        const endPos = landmarkSpheres[end].position;
                        
                        const positions = connectionLines[index].geometry.attributes.position.array;
                        positions[0] = startPos.x;
                        positions[1] = startPos.y;
                        positions[2] = startPos.z;
                        positions[3] = endPos.x;
                        positions[4] = endPos.y;
                        positions[5] = endPos.z;
                        
                        connectionLines[index].geometry.attributes.position.needsUpdate = true;
                        connectionLines[index].visible = true;
                    });
                } else {
                    landmarkSpheres.forEach(sphere => sphere.visible = false);
                    connectionLines.forEach(line => line.visible = false);
                }

                // ãƒ”ãƒ³ãƒæ¤œå‡ºï¼ˆè¦ªæŒ‡ã¨äººå·®ã—æŒ‡ã®è·é›¢ï¼‰
                const pinchDistance = Math.sqrt(
                    Math.pow(indexTip.x - thumbTip.x, 2) +
                    Math.pow(indexTip.y - thumbTip.y, 2) +
                    Math.pow(indexTip.z - thumbTip.z, 2)
                );

                const wasPinching = isPinching;
                if (wasPinching) {
                    isPinching = pinchDistance < PINCH_OFF;
                } else {
                    isPinching = pinchDistance < PINCH_ON;
                }

                // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã¤ã‹ã‚€ï¼ˆé›¢ã—ãŸç›´å¾Œã¯æŠ‘åˆ¶ï¼‰
                if (
                    isPinching && !wasPinching && !grabbedObject &&
                    (performance.now() - lastReleaseTime > GRAB_COOLDOWN_MS)
                ) {
                    // æœ€ã‚‚è¿‘ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¢ã™
                    let closestObject = null;
                    let closestDistance = Infinity;

                    physicsObjects.forEach(obj => {
                        const objPos = new THREE.Vector3(
                            obj.body.position.x,
                            obj.body.position.y,
                            obj.body.position.z
                        );
                        const refPos = filteredHandPosition || handPosition;
                        const distance = refPos.distanceTo(objPos);
                        if (distance < closestDistance && distance < GRAB_DISTANCE) {
                            closestDistance = distance;
                            closestObject = obj;
                        }
                    });

                    if (closestObject) {
                        grabbedObject = closestObject;
                        // å…ƒã®è³ªé‡ã‚’ä¿å­˜ã—ã¦ã‹ã‚‰é‡åŠ›ã‚’ç„¡åŠ¹åŒ–
                        grabbedObject.originalMass = grabbedObject.body.mass;
                        grabbedObject.body.mass = 0;
                        grabbedObject.body.updateMassProperties();
                    }
                }

                // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒã¡ä¸Šã’ã‚‹ï¼ˆæ‰‹ä½ç½®ã¸ç´ æ—©ãè¿½å¾“ã€é…ã‚Œã‚’æŠ‘åˆ¶ï¼‰
                if (grabbedObject && isPinching) {
                    // æ´ã¿ä¸­ã¯ç”Ÿã®æ‰‹ä½ç½®ã‚’å„ªå…ˆã—ã¦è¿½å¾“ï¼ˆãƒ•ã‚£ãƒ«ã‚¿é…å»¶ã‚’å›é¿ï¼‰
                    const target = handPosition;
                    const bx = grabbedObject.body.position.x;
                    const by = grabbedObject.body.position.y;
                    const bz = grabbedObject.body.position.z;
                    const dx = target.x - bx;
                    const dy = target.y - by;
                    const dz = target.z - bz;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

                    if (dist > SNAP_DISTANCE) {
                        // å¤§ããå¤–ã‚ŒãŸã‚‰å³ã‚¹ãƒŠãƒƒãƒ—ã—ã¦é…ã‚Œã‚’è§£æ¶ˆ
                        grabbedObject.body.position.set(target.x, target.y, target.z);
                    } else {
                        // è·é›¢ã«å¿œã˜ã¦è¿½å¾“ä¿‚æ•°ã‚’ä¸Šã’ã‚‹
                        const t = dist / SNAP_DISTANCE;
                        const lerpK = THREE.MathUtils.lerp(FOLLOW_LERP_NEAR, FOLLOW_LERP_FAR, t);
                        grabbedObject.body.position.x += dx * lerpK;
                        grabbedObject.body.position.y += dy * lerpK;
                        grabbedObject.body.position.z += dz * lerpK;
                    }

                    grabbedObject.body.velocity.set(0, 0, 0);
                    // å›è»¢ã¯ã‚†ã£ãã‚Šæ¸›è¡°
                    grabbedObject.body.angularVelocity.scale(0.6, grabbedObject.body.angularVelocity);
                }

                // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ”¾ã™
                if (!isPinching && wasPinching && grabbedObject) {
                    // å…ƒã®è³ªé‡ã‚’å¾©å…ƒ
                    grabbedObject.body.mass = grabbedObject.originalMass || 1;
                    grabbedObject.body.updateMassProperties();
                    
                    // å¹³æ»‘åŒ–ã—ãŸæ‰‹é€Ÿåº¦ã®å¤§ãã•ã§ã€Œè½ã¨ã™/æŠ•ã’ã‚‹ã€ã‚’åˆ†å²
                    const speedNow = filteredHandVelocity.length();

                    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä»£è¡¨åŠå¾„ï¼ˆã‚ªãƒ•ã‚»ãƒƒãƒˆé‡ã«ä½¿ç”¨ï¼‰
                    let radius = 0.5;
                    const geom = grabbedObject.mesh.geometry;
                    if (geom && !geom.boundingSphere) geom.computeBoundingSphere();
                    if (geom && geom.boundingSphere) radius = geom.boundingSphere.radius;

                    if (speedNow < DROP_SPEED_THRESHOLD) {
                        // ãƒ‰ãƒ­ãƒƒãƒ—: æ¨ªæ–¹å‘ã®é€Ÿåº¦ã‚’ä¸ãˆãšã€çœŸä¸‹ã«è‡ªç„¶è½ä¸‹
                        const downOffset = radius * 0.4 + 0.05; // å°‘ã—ä¸‹ã«é›¢ã—ã¦æŒ‡ã¨åˆ†é›¢
                        grabbedObject.body.position.y -= downOffset;
                        grabbedObject.body.velocity.set(0, 0, 0);
                        grabbedObject.body.angularVelocity.set(0, 0, 0);
                    } else {
                        // æŠ•ã’: é€Ÿåº¦ä¸Šé™ã¨ä¿‚æ•°ã§è‡ªç„¶ãªæŠ•æ“²ã«
                        const throwVelocity = filteredHandVelocity.clone();
                        const maxThrow = 12.0;
                        if (speedNow > maxThrow) throwVelocity.multiplyScalar(maxThrow / speedNow);
                        throwVelocity.multiplyScalar(0.6);

                        // æ‰‹ã®é€²è¡Œæ–¹å‘ã¸å°‘ã—é›¢ã—ã¦æŒ‡ã«å¼•ã£ã‹ã‹ã‚‰ãªã„ã‚ˆã†ã«
                        const dir = throwVelocity.clone().normalize();
                        const offset = radius * 0.6 + 0.1;
                        grabbedObject.body.position.x += dir.x * offset;
                        grabbedObject.body.position.y += dir.y * offset;
                        grabbedObject.body.position.z += dir.z * offset;
                        grabbedObject.body.velocity.set(throwVelocity.x, throwVelocity.y, throwVelocity.z);

                        // å›è»¢ã¯æ§ãˆã‚ã«ä»˜ä¸ï¼ˆå¹³æ»‘åŠ é€Ÿåº¦ç”±æ¥ï¼‰
                        const spinFactor = 0.03;
                        grabbedObject.body.angularVelocity.set(
                            filteredHandAcceleration.y * spinFactor,
                            -filteredHandAcceleration.x * spinFactor,
                            filteredHandAcceleration.z * spinFactor
                        );
                    }
                    
                    // æ´ã¿å†é–‹ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
                    lastReleaseTime = performance.now();

                    grabbedObject = null;
                }

            } else {
                statusElement.textContent = 'æœªæ¤œå‡º';
                statusElement.className = 'status inactive';
                handPosition = null;
                
                // é€Ÿåº¦ã¨åŠ é€Ÿåº¦è¡¨ç¤ºã‚’ãƒªã‚»ãƒƒãƒˆ
                handSpeedElement.textContent = '0.0';
                handAccelElement.textContent = '0.0';
                rawZElement.textContent = '0.0';
                
                // ã‚¹ã‚±ãƒ«ãƒˆãƒ³ã‚’éè¡¨ç¤º
                landmarkSpheres.forEach(sphere => sphere.visible = false);
                connectionLines.forEach(line => line.visible = false);
                
                if (grabbedObject) {
                    grabbedObject.body.mass = grabbedObject.originalMass || 1;
                    grabbedObject.body.updateMassProperties();
                    grabbedObject = null;
                }
            }

            canvasCtx.restore();
        }

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        const timeStep = 1 / 60;
        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // ç‰©ç†ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°ï¼ˆå¯å¤‰dtå¯¾å¿œã€æœ€å¤§ã‚µãƒ–ã‚¹ãƒ†ãƒƒãƒ—3ï¼‰
            world.step(timeStep, deltaTime, 3);

            // ç‰©ç†ãƒœãƒ‡ã‚£ã¨ãƒ¡ãƒƒã‚·ãƒ¥ã‚’åŒæœŸ & ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å¤–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤
            for (let i = physicsObjects.length - 1; i >= 0; i--) {
                const obj = physicsObjects[i];
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
                
                // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å¢ƒç•Œåˆ¤å®š
                const bx = obj.body.position.x;
                const by = obj.body.position.y;
                const bz = obj.body.position.z;

                const outOfBounds = (
                    Math.abs(bx) > (FIELD_HALF_SIZE + FIELD_MARGIN) ||
                    Math.abs(bz) > (FIELD_HALF_SIZE + FIELD_MARGIN) ||
                    by < FIELD_MIN_Y || by > FIELD_MAX_Y
                );

                if (outOfBounds) {
                    scene.remove(obj.mesh);
                    world.removeBody(obj.body);
                    physicsObjects.splice(i, 1);
                    
                    // å‰Šé™¤ã‚«ã‚¦ãƒ³ã‚¿ã‚’å¢—ã‚„ã™
                    removedObjectCount++;
                    removedCountElement.textContent = removedObjectCount;
                    
                    // ã¤ã‹ã‚“ã§ã„ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‰Šé™¤ã•ã‚ŒãŸå ´åˆ
                    if (grabbedObject === obj) {
                        grabbedObject = null;
                    }
                    
                    // ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯é˜²æ­¢ã®ãŸã‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                    delete obj.originalMass;
                }
            }
            
            // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°ã‚’æ›´æ–°
            updateObjectCount();

            // FPSè¡¨ç¤º
            physicsFPSElement.textContent = Math.round(1 / deltaTime);

            renderer.render(scene, camera);
        }

        animate();

        // ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
