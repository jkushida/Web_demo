<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hand Drawing - æ”¹å–„ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        #videoElement {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: 1;
            transform: scaleX(-1);
        }
        #canvasContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 2;
        }
        #drawCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 2;
            pointer-events: none;
        }
        #instructions {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 15px;
            font-size: 14px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.1);
            max-width: 300px;
        }
        #instructions h3 {
            margin: 0 0 10px 0;
            font-size: 18px;
            color: #4facfe;
        }
        #instructions ul {
            margin: 0;
            padding-left: 20px;
        }
        #instructions li {
            margin: 8px 0;
            line-height: 1.5;
        }
        #eyeStatus {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 101;
            font-family: 'Courier New', monospace;
            border: 1px solid rgba(255,255,255,0.2);
        }
        #mouthStatus {
            position: absolute;
            top: 45px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 101;
            font-family: 'Courier New', monospace;
            border: 1px solid rgba(255,255,255,0.2);
            transition: color 0.3s;
        }
        #mouthProgressContainer {
            position: absolute;
            top: 80px;
            left: 10px;
            width: 120px;
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            overflow: hidden;
            display: none;
            z-index: 101;
            border: 1px solid rgba(255,255,255,0.4);
        }
        #mouthProgressBar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ee5a6f);
            transition: width 0.1s linear;
        }
        #handsProgressContainer {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 10px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            overflow: hidden;
            display: none;
            z-index: 103;
            border: 2px solid rgba(255,255,255,0.4);
        }
        #handsProgressBar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            transition: width 0.1s linear;
        }
        #handColors {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 12px;
            font-size: 16px;
            z-index: 102;
            display: flex;
            gap: 30px;
            border: 2px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
        }
        #handColors .hand-color-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #handColors span.color-box {
            display: inline-block;
            width: 24px;
            height: 24px;
            border: 2px solid #fff;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        #toggleKeypoints {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 150;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            padding: 12px 20px;
            font-size: 14px;
            border-radius: 8px;
            cursor: pointer;
            color: white;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 2px solid rgba(255,255,255,0.3);
        }
        #toggleKeypoints:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        #toggleKeypoints:active {
            transform: translateY(0);
        }
        #gestureIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 24px;
            z-index: 103;
            display: none;
            font-weight: bold;
            border: 3px solid rgba(255,255,255,0.3);
            animation: fadeInOut 1s ease-in-out;
        }
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
        #strokeCount {
            position: absolute;
            top: 115px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 101;
            font-family: 'Courier New', monospace;
            border: 1px solid rgba(255,255,255,0.2);
        }
        #handsDistance {
            position: absolute;
            top: 150px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 101;
            font-family: 'Courier New', monospace;
            border: 1px solid rgba(255,255,255,0.2);
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="videoElement" autoplay muted></video>
        <div id="canvasContainer"></div>
        <canvas id="drawCanvas"></canvas>
        <div id="eyeStatus">ç›®: L:0.000 R:0.000</div>
        <div id="mouthStatus">å£: 0.000</div>
        <div id="mouthProgressContainer">
          <div id="mouthProgressBar"></div>
        </div>
        <div id="handsProgressContainer">
          <div id="handsProgressBar"></div>
        </div>
        <div id="strokeCount">æç”»æ•°: 0</div>
        <div id="handsDistance">ä¸¡æ‰‹: -</div>
        <div id="handColors">
            <div class="hand-color-item">
                <span>ğŸ‘ˆ å·¦æ‰‹:</span>
                <span class="color-box" id="leftColorBox"></span>
                <code id="leftColorText">#ff0000</code>
            </div>
            <div class="hand-color-item">
                <span>ğŸ‘‰ å³æ‰‹:</span>
                <span class="color-box" id="rightColorBox"></span>
                <code id="rightColorText">#00ff00</code>
            </div>
        </div>
        <button id="toggleKeypoints">ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒˆè¡¨ç¤º</button>
        <div id="gestureIndicator">ğŸ¨ è‰²å¤‰æ›´!</div>
        <div id="instructions">
            <h3>ğŸ“– ä½¿ã„æ–¹</h3>
            <ul>
                <li>ğŸ‘† è¦ªæŒ‡ã¨äººå·®ã—æŒ‡ã‚’ãã£ã¤ã‘ã¦æç”»</li>
                <li>âœŠâ†’âœ‹ ã‚°ãƒ¼ãƒ‘ãƒ¼ã§è‰²å¤‰æ›´</li>
                <li>ğŸ˜‘ ä¸¡ç›®ã‚’é–‰ã˜ã¦å…¨æ¶ˆå»</li>
                <li>ğŸ˜® å£ã‚’é–‹ã‘ã¦å¸åã‚¨ãƒ•ã‚§ã‚¯ãƒˆ</li>
                <li>ğŸ¤² ä¸¡æ‰‹ã‚’åˆã‚ã›ã¦0.8ç§’ã§è½ä¸‹</li>
            </ul>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

    <script>
        // 2D drawing overlay setup
        let drawCanvas, drawCtx;
        let showKeypoints = false;
        const paths = { left: [], right: [] };
        let handColors = { left: 0xff0000, right: 0x00ff00 };

        let winkLeft = false;
        let faceClosed = false;
        let eyeCloseStartTime = null;
        const eyeCloseThreshold = 0.042;   // æ”¹å–„: ã‚ˆã‚Šç¢ºå®Ÿãªæ¤œå‡º
        const eyeCloseDuration = 1200;     // æ”¹å–„: 1.2ç§’ã«å»¶é•·ã—ã¦èª¤æ¤œå‡ºé˜²æ­¢

        // Mouth-open absorption
        const mouthOpenThreshold = 0.14;   // æ”¹å–„: å°‘ã—ä½ã‚ã«èª¿æ•´
        let absorbing = false;
        let absorbStartTime = null;
        const absorbDuration = 500;        // æ”¹å–„: å°‘ã—é•·ã‚ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
        let absorbTarget = { x: 0, y: 0 };
        let mouthOpenReadyTime = null;
        const mouthOpenDelay = 500;        // æ”¹å–„: å°‘ã—çŸ­ã‚ã«
        let barActivated = false;

        let scene, camera, renderer;
        let handDrawings;
        let drawingStates = {};
        let hands, videoElement;
        let currentColor = 0x00ff00;
        
        // æ”¹å–„: ã‚ˆã‚Šè±Šå¯Œãªã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ
        let colors = [
            0xff0000,  // èµ¤
            0x00ff00,  // ç·‘
            0x0000ff,  // é’
            0xffff00,  // é»„
            0xff00ff,  // ãƒã‚¼ãƒ³ã‚¿
            0x00ffff,  // ã‚·ã‚¢ãƒ³
            0xff8800,  // ã‚ªãƒ¬ãƒ³ã‚¸
            0x88ff00,  // é»„ç·‘
            0xff0088,  // ãƒ”ãƒ³ã‚¯
            0x8800ff   // ç´«
        ];
        
        let colorIndex = { left: 0, right: 1 };  // left: red, right: green
        let isInFist = { left:false, right:false };
        let fistTime = { left:0, right:0 };
        const fistThreshold = 0.08;
        const openThreshold = 0.15;
        let lastColorChange = { left: 0, right: 0 };
        const colorChangeCooldown = 600;  // æ”¹å–„: å°‘ã—çŸ­ã‚ã«

        // æ”¹å–„: å·¦å³åˆ¥ã€…ã®æç”»é–‹å§‹é–¾å€¤
        const drawThresholds = { left: 0.06, right: 0.06 };

        // æ”¹å–„: ä¸¡æ‰‹ã‚’åˆã‚ã›ã‚‹æ¤œå‡º
        let handsPausedDrawing = false;
        let handsTogether = false;
        let handsTogetherStartTime = null;
        const handsTogetherThreshold = 0.25; // é–¾å€¤ã‚’å¤§ããã—ã¦æ¤œå‡ºã—ã‚„ã™ã
        const handsTogetherDuration = 800; // 0.8ç§’ä¿æŒã§è½ä¸‹é–‹å§‹
        let lastBothHandsTime = null; // æœ€å¾Œã«ä¸¡æ‰‹ãŒè¦‹ãˆãŸæ™‚åˆ»
        const handsLostTolerance = 300; // ä¸¡æ‰‹ãŒè¦‹ãˆãªããªã£ã¦ã‚‚300msè¨±å®¹

        // è½ä¸‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨
        let falling = false;
        let fallStartTime = null;
        const fallDuration = 2000; // 2ç§’ã‹ã‘ã¦è½ä¸‹
        let fallPhysics = {}; // å„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã®ç‰©ç†ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼‰

        class PositionSmoother {
            constructor(smoothingFactor = 0.65) {  // æ”¹å–„: ã‚ˆã‚Šæ»‘ã‚‰ã‹ã«
                this.factor = smoothingFactor;
                this.lastPosition = null;
            }
            smooth(currentPosition) {
                if (!this.lastPosition) {
                    this.lastPosition = currentPosition.clone();
                    return currentPosition;
                }
                this.lastPosition.lerp(currentPosition, 1 - this.factor);
                return this.lastPosition.clone();
            }
        }

        class HandDrawing {
            constructor(scene) {
                this.scene = scene;
                this.smoother = new PositionSmoother();
                this.lastPosition = null;
                this.minDistance = 0.04;  // æ”¹å–„: ã‚ˆã‚Šç´°ã‹ãè¨˜éŒ²
                this.pathPoints = null;
                this.currentMesh = null;
                this.tubeMaterial = null;
            }
            startPath(position, color = currentColor) {
                const smoothed = this.smoother.smooth(position);
                this.pathPoints = [smoothed.clone()];
                this.tubeMaterial = new THREE.MeshBasicMaterial({ color: color });
                this.currentMesh = null;
                this.lastPosition = smoothed.clone();
            }
            addPoint(position) {
                if (!this.pathPoints) return;
                const smoothed = this.smoother.smooth(position);
                if (this.lastPosition.distanceTo(smoothed) < this.minDistance) return;
                this.pathPoints.push(smoothed.clone());
                this.lastPosition = smoothed.clone();
                if (this.currentMesh) {
                    this.scene.remove(this.currentMesh);
                    this.currentMesh.geometry.dispose();
                }
                const curve = new THREE.CatmullRomCurve3(this.pathPoints);
                const tubeGeo = new THREE.TubeBufferGeometry(curve, this.pathPoints.length * 3, 0.005, 8, false);
                this.currentMesh = new THREE.Mesh(tubeGeo, this.tubeMaterial);
                this.scene.add(this.currentMesh);
            }
            endPath() {
                this.pathPoints = null;
                this.currentMesh = null;
                this.tubeMaterial = null;
                this.smoother = new PositionSmoother();
            }
            clearAll() {
                if (this.currentMesh) {
                    this.scene.remove(this.currentMesh);
                    this.currentMesh.geometry.dispose();
                    if (this.currentMesh.material) this.currentMesh.material.dispose();
                }
                this.pathPoints = null;
                this.currentMesh = null;
                this.tubeMaterial = null;
            }
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            document.getElementById('canvasContainer').appendChild(renderer.domElement);
            camera.position.set(0,0,2);
            handDrawings = { left: new HandDrawing(scene), right: new HandDrawing(scene) };
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            drawAllPaths();
        }

        function initMediaPipe() {
            videoElement = document.getElementById('videoElement');
            hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
            hands.setOptions({ 
                maxNumHands:2, 
                modelComplexity:1, 
                minDetectionConfidence:0.6,  // æ”¹å–„: æ¤œå‡ºç²¾åº¦å‘ä¸Š
                minTrackingConfidence:0.6    // æ”¹å–„: ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ç²¾åº¦å‘ä¸Š
            });
            hands.onResults(onResults);

            const faceMesh = new FaceMesh({
              locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
            });
            faceMesh.setOptions({
              maxNumFaces: 1,
              refineLandmarks: false,
              minDetectionConfidence: 0.6,  // æ”¹å–„
              minTrackingConfidence: 0.6    // æ”¹å–„
            });
            faceMesh.onResults(onFaceResults);

            const camera_mp = new Camera(videoElement, {
              onFrame: async () => {
                await hands.send({ image: videoElement });
                await faceMesh.send({ image: videoElement });
              },
              width: 1920,
              height: 1080
            });
            camera_mp.start();
        }

        function onResults(results) {
            const detected = { left:null, right:null };
            if (showKeypoints && results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    const mirrored = landmarks.map(pt => ({ ...pt, x: 1 - pt.x }));
                    drawConnectors(drawCtx, mirrored, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 2 });
                    drawLandmarks(drawCtx, mirrored, { color: '#FF0000', lineWidth: 1 });
                }
            }
            if (results.multiHandLandmarks) {
                results.multiHandLandmarks.forEach(lm => {
                    // ãƒŸãƒ©ãƒ¼ãƒªãƒ³ã‚°å¯¾å¿œ: x < 0.5ãŒå³æ‰‹ã€x >= 0.5ãŒå·¦æ‰‹
                    const handId = lm[0].x < 0.5 ? 'right' : 'left';
                    detected[handId] = lm;
                });
                
                // æ”¹å–„: ä¸¡æ‰‹ãŒè¿‘ã„ã‹æ¤œå‡ºï¼ˆå®‰å®šåŒ–ç‰ˆï¼‰
                if (detected.left && detected.right) {
                    lastBothHandsTime = Date.now(); // ä¸¡æ‰‹ãŒè¦‹ãˆãŸæ™‚åˆ»ã‚’è¨˜éŒ²
                    
                    const leftPalm = detected.left[0];
                    const rightPalm = detected.right[0];
                    const distance = Math.hypot(
                        leftPalm.x - rightPalm.x, 
                        leftPalm.y - rightPalm.y, 
                        leftPalm.z - rightPalm.z
                    );
                    
                    // UIæ›´æ–°: è·é›¢ã‚’è¡¨ç¤º
                    const distanceEl = document.getElementById('handsDistance');
                    distanceEl.textContent = `ä¸¡æ‰‹: ${distance.toFixed(3)}`;
                    
                    const together = distance < handsTogetherThreshold;
                    distanceEl.style.color = together ? '#00ff00' : 'white';
                    handsPausedDrawing = together;
                    
                    if (together) {
                        if (!handsTogether) {
                            // åˆã‚ã¦åˆã‚ã›ãŸæ™‚ã ã‘
                            handsTogether = true;
                            handsTogetherStartTime = Date.now();
                            console.log('âœ… ä¸¡æ‰‹ã‚’åˆã‚ã›å§‹ã‚ã¾ã—ãŸï¼ 0.8ç§’ä¿æŒã—ã¦ãã ã•ã„');
                        } else {
                            // åˆã‚ã›ç¶šã‘ã¦ã„ã‚‹é–“
                            const elapsed = Date.now() - handsTogetherStartTime;
                            const ratio = Math.min(elapsed / handsTogetherDuration, 1);
                            
                            if (elapsed % 200 < 50) { // 200msã”ã¨ã«è¡¨ç¤º
                                console.log('â³ çµŒéæ™‚é–“:', elapsed, 'ms, é€²æ—:', (ratio * 100).toFixed(1), '%');
                            }
                            
                            // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã‚’è¡¨ç¤ºãƒ»æ›´æ–°
                            const handsProgressContainer = document.getElementById('handsProgressContainer');
                            const handsProgressBar = document.getElementById('handsProgressBar');
                            handsProgressContainer.style.display = 'block';
                            handsProgressBar.style.width = `${100 * ratio}%`;
                            
                            if (elapsed >= handsTogetherDuration && !falling && !absorbing) {
                                // è½ä¸‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆé–‹å§‹
                                console.log('ğŸ¯ 0.8ç§’é”æˆï¼è½ä¸‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆé–‹å§‹!');
                                handsProgressContainer.style.display = 'none';
                                startFallingEffect();
                            }
                        }
                    } else {
                        // æ‰‹ãŒé›¢ã‚ŒãŸ
                        if (handsTogether) {
                            const elapsed = Date.now() - handsTogetherStartTime;
                            console.log('âŒ ä¸¡æ‰‹ã‚’é›¢ã—ã¾ã—ãŸ (çµŒé:', elapsed, 'ms)');
                            handsTogether = false;
                            handsTogetherStartTime = null;
                            document.getElementById('handsProgressContainer').style.display = 'none';
                        }
                    }
                } else {
                    // ç‰‡æ‰‹ã—ã‹æ¤œå‡ºã•ã‚Œã¦ã„ãªã„ï¼ˆã¾ãŸã¯ä¸¡æ‰‹ã¨ã‚‚è¦‹ãˆãªã„ï¼‰
                    // ã§ã‚‚ã€æœ€è¿‘ä¸¡æ‰‹ãŒè¦‹ãˆã¦ã„ãŸãªã‚‰çŒ¶äºˆæœŸé–“ã¨ã—ã¦ç¶™ç¶š
                    if (handsTogether && lastBothHandsTime && (Date.now() - lastBothHandsTime < handsLostTolerance)) {
                        // çŒ¶äºˆæœŸé–“ä¸­ã¯ç¶™ç¶š
                        console.log('âš ï¸ ä¸€æ™‚çš„ã«ç‰‡æ‰‹ãŒè¦‹ãˆã¾ã›ã‚“ãŒç¶™ç¶šä¸­...');
                        const elapsed = Date.now() - handsTogetherStartTime;
                        const ratio = Math.min(elapsed / handsTogetherDuration, 1);
                        
                        // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã¯ç¶™ç¶š
                        const handsProgressContainer = document.getElementById('handsProgressContainer');
                        const handsProgressBar = document.getElementById('handsProgressBar');
                        handsProgressContainer.style.display = 'block';
                        handsProgressBar.style.width = `${100 * ratio}%`;
                        
                        if (elapsed >= handsTogetherDuration && !falling && !absorbing) {
                            console.log('ğŸ¯ 0.8ç§’é”æˆï¼è½ä¸‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆé–‹å§‹!');
                            handsProgressContainer.style.display = 'none';
                            startFallingEffect();
                        }
                    } else if (handsTogether) {
                        // çŒ¶äºˆæœŸé–“ã‚’éããŸã®ã§ãƒªã‚»ãƒƒãƒˆ
                        console.log('âŒ ç‰‡æ‰‹ãŒè¦‹ãˆãªããªã‚Šã¾ã—ãŸï¼ˆçŒ¶äºˆæœŸé–“çµ‚äº†ï¼‰');
                        document.getElementById('handsDistance').textContent = 'ä¸¡æ‰‹: -';
                        handsPausedDrawing = false;
                        handsTogether = false;
                        handsTogetherStartTime = null;
                        document.getElementById('handsProgressContainer').style.display = 'none';
                    } else {
                        // å…ƒã€…æ¤œå‡ºã—ã¦ã„ãªã‹ã£ãŸ
                        document.getElementById('handsDistance').textContent = 'ä¸¡æ‰‹: -';
                        handsPausedDrawing = false;
                    }
                }
            }
            Object.entries(detected).forEach(([id,lm])=>{ if(lm) processHandGesture(lm,id); });
        }

        function onFaceResults(results) {
          if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
            const lm = results.multiFaceLandmarks[0];
            const topEyeL = lm[159], bottomEyeL = lm[145];
            const topEyeR = lm[386], bottomEyeR = lm[374];
            const eyeDistL = bottomEyeL.y - topEyeL.y;
            const eyeDistR = bottomEyeR.y - topEyeR.y;
            const chin = lm[152], forehead = lm[10];
            const faceHeight = chin.y - forehead.y;
            const ratioL = eyeDistL / faceHeight;
            const ratioR = eyeDistR / faceHeight;
            
            // æ”¹å–„: ã‚ˆã‚Šç¢ºå®Ÿãªé–¾å€¤
            const closeTh = 0.040;
            const openTh  = 0.070;
            
            if (ratioL < closeTh) {
              faceClosed = true;
              winkLeft = false;
            } else if (ratioL > openTh) {
              if (faceClosed) {
                winkLeft = true;
                faceClosed = false;
              } else {
                winkLeft = false;
              }
            } else {
              winkLeft = false;
            }
            
            const upperLip = lm[13], lowerLip = lm[14];
            const mouthDist = (lowerLip.y - upperLip.y) / (chin.y - forehead.y);
            
            document.getElementById('eyeStatus').textContent =
              `ç›®: L:${ratioL.toFixed(3)} R:${ratioR.toFixed(3)}`;

            // ä¸¡ç›®ã‚’é–‰ã˜ã¦ä¸€å®šæ™‚é–“çµŒéã—ãŸã‚‰ç·šã‚’ã‚¯ãƒªã‚¢
            if (ratioL < eyeCloseThreshold && ratioR < eyeCloseThreshold) {
              if (eyeCloseStartTime === null) {
                eyeCloseStartTime = Date.now();
              } else if (Date.now() - eyeCloseStartTime > eyeCloseDuration) {
                clearDrawing();
                showGestureIndicator('ğŸ—‘ï¸ ã‚¯ãƒªã‚¢!');
                eyeCloseStartTime = null;
              }
            } else {
              eyeCloseStartTime = null;
            }
            
            document.getElementById('mouthStatus').textContent = `å£: ${mouthDist.toFixed(3)}`;
            const mouthEl = document.getElementById('mouthStatus');
            if (mouthDist > mouthOpenThreshold) {
              mouthEl.style.color = '#ff6b6b';
            } else {
              mouthEl.style.color = 'white';
            }
            
            const progressContainer = document.getElementById('mouthProgressContainer');
            const progressBar = document.getElementById('mouthProgressBar');
            if (mouthDist > mouthOpenThreshold && !barActivated) {
              if (mouthOpenReadyTime === null) {
                mouthOpenReadyTime = Date.now();
              }
              const elapsed = Date.now() - mouthOpenReadyTime;
              const ratio = Math.min(elapsed / mouthOpenDelay, 1);
              progressBar.style.width = `${100 * (1 - ratio)}%`;
              progressContainer.style.display = 'block';
              if (ratio >= 1) {
                barActivated = true;
                progressContainer.style.display = 'none';
              }
            } else if (mouthDist <= mouthOpenThreshold) {
              mouthOpenReadyTime = null;
              barActivated = false;
              progressContainer.style.display = 'none';
            }
            
            if (mouthDist > mouthOpenThreshold) {
              if (mouthOpenReadyTime === null) {
                mouthOpenReadyTime = Date.now();
              } else if (!absorbing && (Date.now() - mouthOpenReadyTime > mouthOpenDelay)) {
                absorbing = true;
                absorbStartTime = Date.now();
                mouthOpenReadyTime = null;
                const mx = (1 - (upperLip.x + lowerLip.x)/2) * window.innerWidth;
                const my = ((upperLip.y + lowerLip.y)/2) * window.innerHeight;
                absorbTarget = { x: mx, y: my };
                showGestureIndicator('ğŸ’« å¸å!');
              }
            } else {
              mouthOpenReadyTime = null;
            }
            
            if (showKeypoints) {
                const mirroredFace = lm.map(pt => ({ ...pt, x: 1 - pt.x }));
                drawConnectors(drawCtx, mirroredFace, FACEMESH_TESSELATION, { color: '#C0C0C070', lineWidth: 1 });
                drawLandmarks(drawCtx, mirroredFace, { color: '#FF3030', radius: 0.5 });
            }
          } else {
            faceClosed = false;
            winkLeft = false;
          }
        }

        function processHandGesture(landmarks, handId) {
            const t = landmarks[4], i = landmarks[8];
            const d = Math.hypot(t.x - i.x, t.y - i.y, t.z - i.z);
            const mp = { x: (t.x + i.x) / 2, y: (t.y + i.y) / 2, z: (t.z + i.z) / 2 };
            const px = (1 - mp.x) * window.innerWidth;
            const py = mp.y * window.innerHeight;
            const shouldDraw = d < drawThresholds[handId] && !handsPausedDrawing;

            // Fist-to-open gesture detection
            const fingerTipIds = [8, 12, 16, 20];
            const isFistNow = fingerTipIds.every(id => {
                const tip = landmarks[id];
                const pip = landmarks[id - 2];
                return tip.y > pip.y;
            });
            const isOpenNow = fingerTipIds.every(id => {
                const tip = landmarks[id];
                const pip = landmarks[id - 2];
                return tip.y < pip.y;
            });
            
            if (isFistNow && !isInFist[handId]) {
                isInFist[handId] = true;
                fistTime[handId] = Date.now();
            } else if (
                isOpenNow && isInFist[handId] && (Date.now() - fistTime[handId]) < 500
                && (Date.now() - lastColorChange[handId] > colorChangeCooldown)
            ) {
                isInFist[handId] = false;
                colorIndex[handId] = (colorIndex[handId] + 1) % colors.length;
                handColors[handId] = colors[colorIndex[handId]];
                showGestureIndicator('ğŸ¨ è‰²å¤‰æ›´!');
                updateHandColors();
                lastColorChange[handId] = Date.now();
            } else if (isOpenNow) {
                isInFist[handId] = false;
            }

            if (shouldDraw) {
                if (!drawingStates[handId]) {
                    drawingStates[handId] = true;
                    paths[handId].push({ points: [], color: handColors[handId] });
                }
                const currentStroke = paths[handId][paths[handId].length - 1];
                currentStroke.points.push({ x: px, y: py });
            } else {
                if (drawingStates[handId]) {
                    drawingStates[handId] = false;
                }
            }
            updateHandColors();
            updateStrokeCount();
        }

        function drawAllPaths() {
            // è½ä¸‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‡¦ç†
            if (falling) {
                console.log('drawAllPaths: è½ä¸‹ä¸­!, falling=', falling);
                const t = Math.min((Date.now() - fallStartTime) / fallDuration, 1);
                console.log('è½ä¸‹é€²æ— t=', t.toFixed(3));
                // Ease in quad for acceleration
                const easedT = t * t;
                
                drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                
                let allHandIds = Object.keys(paths);
                allHandIds.forEach(handId => {
                    paths[handId].forEach((stroke, strokeIdx) => {
                        const pts = stroke.points;
                        if (pts.length < 2) return;
                        
                        if (!stroke.originalPoints) {
                            stroke.originalPoints = stroke.points.map(p => ({...p}));
                        }
                        
                        const key = `${handId}-${strokeIdx}`;
                        if (!fallPhysics[key]) {
                            // å„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã«ãƒ©ãƒ³ãƒ€ãƒ ãªç‰©ç†ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å‰²ã‚Šå½“ã¦
                            fallPhysics[key] = {
                                velocityX: (Math.random() - 0.5) * 200, // æ¨ªæ–¹å‘ã®åˆé€Ÿåº¦
                                rotation: (Math.random() - 0.5) * Math.PI * 4, // å›è»¢
                                swingAmp: Math.random() * 100 + 50, // æºã‚Œå¹…
                                swingFreq: Math.random() * 3 + 2 // æºã‚Œå‘¨æ³¢æ•°
                            };
                        }
                        
                        const physics = fallPhysics[key];
                        // é‡åŠ›åŠ é€Ÿåº¦
                        const gravity = 1500; // pixels/sÂ²
                        const fallDistance = 0.5 * gravity * Math.pow(t, 2);
                        
                        // æ¨ªæºã‚Œï¼ˆã‚µã‚¤ãƒ³æ³¢ï¼‰
                        const swingOffset = Math.sin(t * physics.swingFreq * Math.PI * 2) * physics.swingAmp * t;
                        
                        // å›è»¢è§’åº¦
                        const angle = physics.rotation * t;
                        
                        // å„ç‚¹ã‚’å¤‰æ›
                        stroke.points = stroke.originalPoints.map(p => {
                            // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã®ä¸­å¿ƒç‚¹ã‚’è¨ˆç®—
                            const centerX = stroke.originalPoints.reduce((sum, pt) => sum + pt.x, 0) / stroke.originalPoints.length;
                            const centerY = stroke.originalPoints.reduce((sum, pt) => sum + pt.y, 0) / stroke.originalPoints.length;
                            
                            // ä¸­å¿ƒã‹ã‚‰ã®ç›¸å¯¾ä½ç½®
                            const relX = p.x - centerX;
                            const relY = p.y - centerY;
                            
                            // å›è»¢è¡Œåˆ—ã‚’é©ç”¨
                            const rotatedX = relX * Math.cos(angle) - relY * Math.sin(angle);
                            const rotatedY = relX * Math.sin(angle) + relY * Math.cos(angle);
                            
                            return {
                                x: centerX + rotatedX + swingOffset + physics.velocityX * t,
                                y: centerY + rotatedY + fallDistance
                            };
                        });
                        
                        // é€æ˜åº¦ã‚’å¾ã€…ã«ä¸‹ã’ã‚‹
                        const opacity = 1 - easedT * 0.5;
                        drawCtx.globalAlpha = opacity;
                        
                        drawCtx.strokeStyle = '#' + stroke.color.toString(16).padStart(6, '0');
                        drawCtx.lineWidth = 5;
                        drawCtx.lineCap = 'round';
                        drawCtx.lineJoin = 'round';
                        drawCtx.beginPath();
                        drawCtx.moveTo(pts[0].x, pts[0].y);
                        for (let i = 1; i < pts.length; i++) {
                            drawCtx.lineTo(pts[i].x, pts[i].y);
                        }
                        drawCtx.stroke();
                    });
                });
                
                drawCtx.globalAlpha = 1.0;
                
                if (t >= 1) {
                    falling = false;
                    fallPhysics = {};
                    clearDrawing();
                    return;
                }
                return;
            }
            
            if (absorbing) {
              const t = Math.min((Date.now() - absorbStartTime)/absorbDuration, 1);
              // Ease out cubic for smoother animation
              const easedT = 1 - Math.pow(1 - t, 3);
              
              Object.keys(paths).forEach(handId => {
                paths[handId].forEach(stroke => {
                  if (!stroke.originalPoints) {
                    stroke.originalPoints = stroke.points.map(p => ({...p}));
                  }
                  stroke.points = stroke.originalPoints.map(p => ({
                    x: p.x * (1 - easedT) + absorbTarget.x * easedT,
                    y: p.y * (1 - easedT) + absorbTarget.y * easedT
                  }));
                });
              });
              
              drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
              Object.keys(paths).forEach(handId => {
                  const strokes = paths[handId];
                  strokes.forEach(stroke => {
                      const pts = stroke.points;
                      if (pts.length < 2) return;
                      drawCtx.strokeStyle = '#' + stroke.color.toString(16).padStart(6, '0');
                      drawCtx.lineWidth = 5;  // æ”¹å–„: å°‘ã—å¤ªã‚ã«
                      drawCtx.lineCap = 'round';  // æ”¹å–„: ä¸¸ã„ç«¯
                      drawCtx.lineJoin = 'round';
                      drawCtx.beginPath();
                      drawCtx.moveTo(pts[0].x, pts[0].y);
                      for (let i = 1; i < pts.length; i++) {
                          drawCtx.lineTo(pts[i].x, pts[i].y);
                      }
                      drawCtx.stroke();
                  });
              });
              
              if (t >= 1) {
                absorbing = false;
                clearDrawing();
                return;
              }
              return;
            }
            
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            Object.keys(paths).forEach(handId => {
                const strokes = paths[handId];
                strokes.forEach(stroke => {
                    const pts = stroke.points;
                    if (pts.length < 2) return;
                    drawCtx.strokeStyle = '#' + stroke.color.toString(16).padStart(6, '0');
                    drawCtx.lineWidth = 5;
                    drawCtx.lineCap = 'round';
                    drawCtx.lineJoin = 'round';
                    drawCtx.beginPath();
                    drawCtx.moveTo(pts[0].x, pts[0].y);
                    for (let i = 1; i < pts.length; i++) {
                        drawCtx.lineTo(pts[i].x, pts[i].y);
                    }
                    drawCtx.stroke();
                });
            });
        }

        function clearDrawing(){
            drawingStates={};
            Object.values(handDrawings).forEach(d=>d.clearAll());
            paths.left = [];
            paths.right = [];
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            updateStrokeCount();
        }

        function updateHandColors() {
            const lc = '#' + handColors.left.toString(16).padStart(6, '0');
            const rc = '#' + handColors.right.toString(16).padStart(6, '0');
            document.getElementById('leftColorBox').style.backgroundColor = lc;
            document.getElementById('leftColorText').textContent = lc;
            document.getElementById('rightColorBox').style.backgroundColor = rc;
            document.getElementById('rightColorText').textContent = rc;
        }

        // æ”¹å–„: æç”»æ•°ã‚«ã‚¦ãƒ³ãƒˆè¡¨ç¤º
        function updateStrokeCount() {
            const totalStrokes = paths.left.length + paths.right.length;
            document.getElementById('strokeCount').textContent = `æç”»æ•°: ${totalStrokes}`;
        }

        // æ”¹å–„: ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼
        function showGestureIndicator(text) {
            const indicator = document.getElementById('gestureIndicator');
            indicator.textContent = text;
            indicator.style.display = 'block';
            setTimeout(() => {
                indicator.style.display = 'none';
            }, 1000);
        }

        // è½ä¸‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆé–‹å§‹
        function startFallingEffect() {
            const totalStrokes = paths.left.length + paths.right.length;
            console.log('startFallingEffect called, ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯æ•°:', totalStrokes);
            console.log('falling flag before:', falling);
            console.log('absorbing flag:', absorbing);
            
            if (totalStrokes === 0) {
                console.log('æç”»ãŒãªã„ãŸã‚ã€è½ä¸‹ã‚’ã‚¹ã‚­ãƒƒãƒ—');
                return;
            }
            
            falling = true;
            fallStartTime = Date.now();
            fallPhysics = {};
            showGestureIndicator('ğŸŒŠ è½ä¸‹!');
            handsTogether = false;
            handsTogetherStartTime = null;
            
            console.log('è½ä¸‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆé–‹å§‹å®Œäº†! falling flag:', falling);
        }

        window.addEventListener('resize',()=>{ 
            camera.aspect=window.innerWidth/window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth,window.innerHeight); 
        });
        
        window.addEventListener('load',()=>{
            initThreeJS();
            initMediaPipe();
            drawCanvas = document.getElementById('drawCanvas');
            drawCtx = drawCanvas.getContext('2d');
            function resizeDrawCanvas() {
                drawCanvas.width = window.innerWidth;
                drawCanvas.height = window.innerHeight;
            }
            resizeDrawCanvas();
            window.addEventListener('resize', resizeDrawCanvas);
            updateHandColors();
            updateStrokeCount();
            animate();
            
            document.getElementById('toggleKeypoints').addEventListener('click', () => {
                showKeypoints = !showKeypoints;
                document.getElementById('toggleKeypoints').textContent = 
                    showKeypoints ? 'ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒˆéè¡¨ç¤º' : 'ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒˆè¡¨ç¤º';
            });
        });
    </script>
</body>
</html>
