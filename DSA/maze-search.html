<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DSA: è¿·è·¯ã®æ¢ç´¢ (BFS/DFS)</title>
    <style>
      :root { color-scheme: light dark; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
      h1 { font-size: 20px; margin: 0 0 8px; }
      .panel { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin-bottom: 12px; }
      .panel > * { margin: 0; }
      .legend { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
      .legend span { display: inline-flex; align-items: center; gap: 6px; font-size: 12px; }
      .box { width: 14px; height: 14px; border: 1px solid #888; display: inline-block; }
      canvas { border: 1px solid #bbb; background: #fff; max-width: 100%; height: auto; }
      .note { font-size: 12px; color: #555; margin-top: 6px; }
      button { padding: 6px 10px; }
      label { font-size: 14px; }
      .sep { width: 1px; height: 20px; background: #ccc; margin: 0 4px; }
      .layout { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; align-items: start; }
      .treePane { border: 1px solid #bbb; background: #fff; padding: 8px; overflow: auto; }
      .treeHead { display:flex; align-items:center; justify-content:space-between; margin-bottom:6px; font-size: 13px; }
      svg { max-width: 100%; background: #fff; }
    </style>
  </head>
  <body>
    <h1>è¿·è·¯ã®æ¢ç´¢ (å¹…å„ªå…ˆ / æ·±ã•å„ªå…ˆ)</h1>

    <div class="panel">
      <label>
        ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼š
        <select id="algo">
          <option value="bfs">å¹…å„ªå…ˆæ¢ç´¢ (BFS)</option>
          <option value="dfs">æ·±ã•å„ªå…ˆæ¢ç´¢ (DFS)</option>
        </select>
      </label>

      <span class="sep"></span>

      <button id="play">â–¶ å†ç”Ÿ</button>
      <button id="step">â­ 1ã‚¹ãƒ†ãƒƒãƒ—</button>
      <button id="reset">â†º ãƒªã‚»ãƒƒãƒˆ</button>
      <button id="clearLog">ğŸ§¹ ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢</button>

      <span class="sep"></span>

      <label>
        é€Ÿåº¦: <input id="speed" type="range" min="50" max="800" value="300" />
      </label>

      <span id="info">STEP: 0 / æ¢ç´¢ä¸­</span>
    </div>

    <div class="legend" aria-hidden="true">
      <span><i class="box" style="background:#000"></i> å£</span>
      <span><i class="box" style="background:#fff"></i> é€šè·¯</span>
      <span><i class="box" style="background:#a3c4f3"></i> è¨ªå•æ¸ˆã¿</span>
      <span><i class="box" style="background:#4f8ef7"></i> å¢ƒç•Œ(å¾…ã¡è¡Œåˆ—/ã‚¹ã‚¿ãƒƒã‚¯)</span>
      <span><i class="box" style="background:#fde047"></i> çµŒè·¯</span>
      <span><i class="box" style="background:#1e40af"></i> ã‚´ãƒ¼ãƒ«</span>
      <span><i class="box" style="background:#fff; border-radius:50%; background:radial-gradient(circle at center, #e11d48 0 60%, transparent 61%)"></i> ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ</span>
    </div>

    <div class="layout">
      <div>
        <canvas id="view" width="480" height="360" aria-label="maze"></canvas>
        <div class="note">èµ¤ã„ä¸¸ãŒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã€æ¿ƒã„é’ãŒã‚´ãƒ¼ãƒ«ã€‚å³ä¸‹ã®ã‚»ãƒ«ã‚‚å£ã¨ã—ã¦æ‰±ã„ã¾ã™ã€‚</div>
        <div id="log" class="log" role="log" aria-live="polite" style="margin-top:10px; padding:8px; border:1px solid #bbb; background: color-mix(in oklab, Canvas 92%, black 0%); max-height: 260px; overflow:auto; font: 12px/1.5 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre-wrap;"></div>
      </div>
      <div class="treePane">
        <div class="treeHead"><span>æ¢ç´¢æœ¨ï¼ˆå‹•çš„ï¼‰</span><span id="treeInfo"></span></div>
        <svg id="treeSvg" width="600" height="420" viewBox="0 0 600 420" xmlns="http://www.w3.org/2000/svg" aria-label="search tree"></svg>
        <div class="note">å±¤=æ·±ã•, å·¦â†’å³=ç™ºè¦‹é †ã€‚é»„è‰²=ç¢ºå®šçµŒè·¯ã€‚</div>
      </div>
    </div>
    <div class="note">èµ¤ã„ä¸¸ãŒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã€æ¿ƒã„é’ãŒã‚´ãƒ¼ãƒ«ã€‚å³ä¸‹ã®ã‚»ãƒ«ã‚‚å£ã¨ã—ã¦æ‰±ã„ã¾ã™ã€‚</div>

    <script>
      // è¿·è·¯: å£=9, é€šè·¯=0, ã‚´ãƒ¼ãƒ«=1
      // Pythonç‰ˆã®ã‚µãƒ³ãƒ—ãƒ«ã‹ã‚‰ç°¡ç•¥åŒ–ãƒ»è»¢è¨˜
      const maze = [
        [9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9],
        [9, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 9],
        [9, 0, 9, 0, 0, 0, 9, 9, 0, 9, 0, 9],
        [9, 0, 9, 9, 0, 9, 0, 0, 0, 9, 1, 9],
        [9, 0, 9, 0, 0, 0, 0, 9, 0, 0, 9, 9],
        [9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9]
      ];

      const H = maze.length;
      const W = maze[0].length;
      const cellSize = 32; // ã‚»ãƒ«æç”»ã‚µã‚¤ã‚ºï¼ˆpxï¼‰
      const margin = { left: 40, right: 10, top: 10, bottom: 40 }; // è»¸ç”¨ä½™ç™½
      const view = document.getElementById('view');
      view.width = W * cellSize + margin.left + margin.right;
      view.height = H * cellSize + margin.top + margin.bottom;
      const ctx = view.getContext('2d');
      const treeSvg = document.getElementById('treeSvg');

      // ã‚¹ã‚¿ãƒ¼ãƒˆã¯å·¦ä¸Šå´ã®æœ€åˆã®é€šè·¯ã‚»ãƒ«ã€ã‚´ãƒ¼ãƒ«ã¯å€¤1ã®ã‚»ãƒ«
      const start = (() => {
        for (let i = 0; i < H; i++) {
          for (let j = 0; j < W; j++) {
            if (maze[i][j] === 0) return [i, j];
          }
        }
        return [1, 1];
      })();
      const goal = (() => {
        for (let i = 0; i < H; i++) {
          for (let j = 0; j < W; j++) {
            if (maze[i][j] === 1) return [i, j];
          }
        }
        return null;
      })();

      // æ¢ç´¢çŠ¶æ…‹
      let algo = 'bfs';
      let running = false;
      let stepTimer = null;
      let stepDelay = 300;
      let stepCount = 0;
      let finished = false;

      const inBounds = (i, j) => i >= 0 && i < H && j >= 0 && j < W;
      const dirs = [
        [1, 0], // ä¸‹
        [0, 1], // å³
        [-1, 0], // ä¸Š
        [0, -1] // å·¦
      ];

      // å¯è¦–åŒ–ç”¨ãƒãƒƒãƒ•ã‚¡
      let visited, frontier, parent, agentPos, pathSet;
      let container; // è¦ç´ ã¯ [i, j, depth]
      let depthMap, orderMap, discCounter;

      function resetState() {
        visited = Array.from({ length: H }, () => Array(W).fill(false));
        frontier = Array.from({ length: H }, () => Array(W).fill(false));
        parent = Array.from({ length: H }, () => Array(W).fill(null));
        agentPos = [...start];
        pathSet = new Set();
        stepCount = 0;
        finished = false;
        container = [];
        depthMap = Array.from({ length: H }, () => Array(W).fill(-1));
        orderMap = Array.from({ length: H }, () => Array(W).fill(-1));
        discCounter = 0;
        // åˆæœŸç™»éŒ²
        if (maze[start[0]][start[1]] !== 9) {
          container.push([start[0], start[1], 0]);
          frontier[start[0]][start[1]] = true;
          depthMap[start[0]][start[1]] = 0;
          orderMap[start[0]][start[1]] = discCounter++;
        }
        draw();
        updateInfo();
      }

      function updateInfo() {
        const info = document.getElementById('info');
        info.textContent = `STEP: ${stepCount} / ${finished ? 'å®Œäº†' : 'æ¢ç´¢ä¸­'}`;
      }

      function reconstructPath(to) {
        pathSet.clear();
        let cur = to;
        while (cur) {
          pathSet.add(cur.join(','));
          cur = parent[cur[0]][cur[1]];
        }
      }

      function stepOnce() {
        if (finished) return;
        if (container.length === 0) {
          finished = true;
          updateInfo();
          draw();
          return;
        }

        // ãƒ­ã‚°: äº‹å‰ã®æ¢ç´¢ãƒªã‚¹ãƒˆ
        appendLog(`step= ${stepCount + 1}`);
        appendLog('æ¢ç´¢ãƒªã‚¹ãƒˆ[h, w, depth]:  ' + serializeContainer(container));

        // BFS: shift / DFS: pop
        const cur = algo === 'bfs' ? container.shift() : container.pop();
        const [i, j, dpth] = cur;
        appendLog('pop ' + fmtEntry(cur));
        frontier[i][j] = false;
        if (visited[i][j]) {
          // æ—¢ã«é–‰è·¯æ‰±ã„ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
          appendLog(`ç¾åœ¨åœ°[${i}][${j}]ã¯æ—¢ã«è¨ªå•æ¸ˆã¿ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—`);
          draw();
          return;
        }
        visited[i][j] = true;
        appendLog(`ç¾åœ¨åœ°[${i}][${j}]ã‚’æ¢ç´¢æ¸ˆã¿ã¨ã—ã¦ã‚»ãƒƒãƒˆ`);
        agentPos = [i, j];
        stepCount++;

        // ã‚´ãƒ¼ãƒ«åˆ¤å®š
        if (goal && i === goal[0] && j === goal[1]) {
          reconstructPath([i, j]);
          finished = true;
          updateInfo();
          draw();
          appendLog('goal');
          return;
        }

        for (const [di, dj] of dirs) {
          const ni = i + di, nj = j + dj;
          if (!inBounds(ni, nj)) continue;
          if (maze[ni][nj] === 9) continue; // å£
          if (visited[ni][nj]) continue;
          if (!frontier[ni][nj]) {
            parent[ni][nj] = [i, j];
            frontier[ni][nj] = true;
            container.push([ni, nj, dpth + 1]);
            if (depthMap[ni][nj] < 0) depthMap[ni][nj] = dpth + 1;
            if (orderMap[ni][nj] < 0) orderMap[ni][nj] = discCounter++;
          }
        }

        appendLog('æ›´æ–°å¾Œã®æ¢ç´¢ãƒªã‚¹ãƒˆ ' + serializeContainer(container));
        draw();
        updateInfo();
      }

      function draw() {
        ctx.clearRect(0, 0, view.width, view.height);
        for (let i = 0; i < H; i++) {
          for (let j = 0; j < W; j++) {
            const x = margin.left + j * cellSize;
            const y = margin.top + i * cellSize;

            // èƒŒæ™¯ï¼ˆå£/é€šè·¯ï¼‰
            if (maze[i][j] === 9) {
              ctx.fillStyle = '#000';
            } else {
              ctx.fillStyle = '#fff';
            }
            ctx.fillRect(x, y, cellSize, cellSize);

            // å¢ƒç•Œï¼ˆfrontierï¼‰
            if (frontier[i][j]) {
              ctx.fillStyle = '#4f8ef7';
              ctx.globalAlpha = 0.35;
              ctx.fillRect(x, y, cellSize, cellSize);
              ctx.globalAlpha = 1;
            }

            // è¨ªå•æ¸ˆã¿ï¼ˆclosedï¼‰
            if (visited[i][j]) {
              ctx.fillStyle = '#a3c4f3';
              ctx.globalAlpha = 0.6;
              ctx.fillRect(x, y, cellSize, cellSize);
              ctx.globalAlpha = 1;
            }

            // çµŒè·¯
            if (pathSet.has(i + ',' + j)) {
              ctx.fillStyle = '#fde047';
              ctx.globalAlpha = 0.9;
              ctx.fillRect(x, y, cellSize, cellSize);
              ctx.globalAlpha = 1;
            }

            // ã‚´ãƒ¼ãƒ«
            if (goal && i === goal[0] && j === goal[1]) {
              ctx.fillStyle = '#1e40af';
              ctx.globalAlpha = 0.85;
              ctx.fillRect(x + 4, y + 4, cellSize - 8, cellSize - 8);
              ctx.globalAlpha = 1;
            }

            // æ ç·š
            ctx.strokeStyle = '#ddd';
            ctx.strokeRect(x, y, cellSize, cellSize);
          }
        }

        // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆèµ¤ä¸¸ï¼‰
        const [ai, aj] = agentPos;
        ctx.beginPath();
        ctx.fillStyle = '#e11d48';
        ctx.arc(
          margin.left + aj * cellSize + cellSize / 2,
          margin.top + ai * cellSize + cellSize / 2,
          Math.min(cellSize * 0.35, 12),
          0,
          Math.PI * 2
        );
        ctx.fill();
        drawAxes();
        drawTree();
      }

      function drawAxes() {
        const gridLeft = margin.left;
        const gridTop = margin.top;
        const gridRight = margin.left + W * cellSize;
        const gridBottom = margin.top + H * cellSize;

        ctx.save();
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 1;
        ctx.beginPath();
        // xè»¸
        ctx.moveTo(gridLeft, gridBottom);
        ctx.lineTo(gridRight, gridBottom);
        // yè»¸
        ctx.moveTo(gridLeft, gridTop);
        ctx.lineTo(gridLeft, gridBottom);
        ctx.stroke();

        // ç›®ç››ã‚Šã¨ãƒ©ãƒ™ãƒ«
        ctx.fillStyle = '#111';
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
        // x ticks/labels
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        for (let j = 0; j < W; j++) {
          const x = gridLeft + j * cellSize + cellSize / 2;
          ctx.fillText(String(j), x, gridBottom + 6);
        }
        // y ticks/labels
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        for (let i = 0; i < H; i++) {
          const y = gridTop + i * cellSize + cellSize / 2;
          ctx.fillText(String(i), gridLeft - 6, y);
        }
        // è»¸ãƒ©ãƒ™ãƒ«
        // w (x axis)
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('w', (gridLeft + gridRight) / 2, gridBottom + 22);
        // h (y axis, vertical)
        ctx.translate(gridLeft - 24, (gridTop + gridBottom) / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'alphabetic';
        ctx.fillText('h', 0, 0);
        ctx.restore();
      }

      function drawTree() {
        // æ§‹ç¯‰: ç™ºè¦‹æ¸ˆã¿ãƒãƒ¼ãƒ‰ã¨è¦ªå­ã‚¨ãƒƒã‚¸
        const nodes = [];
        const edges = [];
        let maxDepth = 0;
        for (let i = 0; i < H; i++) {
          for (let j = 0; j < W; j++) {
            if (depthMap[i][j] >= 0) {
              const key = i + ',' + j;
              nodes.push({
                i, j,
                key,
                depth: depthMap[i][j],
                order: orderMap[i][j],
                visited: visited[i][j],
                frontier: frontier[i][j],
                isGoal: goal && i === goal[0] && j === goal[1],
                inPath: pathSet.has(key),
                isAgent: agentPos[0] === i && agentPos[1] === j
              });
              maxDepth = Math.max(maxDepth, depthMap[i][j]);
              const p = parent[i][j];
              if (p) {
                edges.push({ from: p[0] + ',' + p[1], to: key });
              }
            }
          }
        }

        // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ: æ·±ã•åˆ¥ã«ä¸¦ã¹ã€ç™ºè¦‹é †ã§æ°´å¹³é…ç½®
        const levels = Array.from({ length: maxDepth + 1 }, () => []);
        nodes.sort((a, b) => a.order - b.order);
        for (const n of nodes) levels[n.depth].push(n);

        const hGap = 70; // ãƒãƒ¼ãƒ‰é–“Xé–“éš”ã®ç›®å®‰
        const vGap = 70; // å±¤é–“Yé–“éš”
        const radius = 12;
        let viewW = 600;
        const viewH = Math.max(300, (maxDepth + 1) * vGap + 60);

        // xåº§æ¨™ã®å‰²ã‚Šå½“ã¦
        for (let d = 0; d <= maxDepth; d++) {
          const row = levels[d];
          const widthNeeded = Math.max(1, row.length) * hGap + 60;
          viewW = Math.max(viewW, widthNeeded);
          row.forEach((n, idx) => {
            n.x = ((idx + 1) * (widthNeeded / (row.length + 1)));
            n.y = 30 + d * vGap;
          });
        }

        // ãƒãƒ¼ãƒ‰ä½ç½®è¾æ›¸
        const pos = new Map(nodes.map(n => [n.key, { x: n.x, y: n.y, n }]));

        // SVGå‡ºåŠ›
        treeSvg.setAttribute('viewBox', `0 0 ${viewW} ${viewH}`);
        treeSvg.setAttribute('width', Math.min(viewW, 600));
        treeSvg.setAttribute('height', viewH);

        const parts = [];
        // edges
        for (const e of edges) {
          const a = pos.get(e.from); const b = pos.get(e.to);
          if (!a || !b) continue;
          const inPathEdge = a.n.inPath && b.n.inPath;
          const stroke = inPathEdge ? '#f59e0b' : '#94a3b8';
          const sw = inPathEdge ? 2.5 : 1.2;
          parts.push(`<line x1="${a.x}" y1="${a.y}" x2="${b.x}" y2="${b.y}" stroke="${stroke}" stroke-width="${sw}" />`);
        }
        // nodes
        for (const n of nodes) {
          let fill = '#ffffff';
          let stroke = '#334155';
          if (n.visited) fill = '#bfdbfe';
          if (n.frontier) fill = '#93c5fd';
          if (n.inPath) fill = '#fde047';
          if (n.isGoal) stroke = '#1e40af';
          const ring = n.isAgent ? `<circle cx="${n.x}" cy="${n.y}" r="${radius + 3}" fill="none" stroke="#e11d48" stroke-width="2" />` : '';
          parts.push(`
            <g>
              <circle cx="${n.x}" cy="${n.y}" r="${radius}" fill="${fill}" stroke="${stroke}" stroke-width="1.2" />
              ${ring}
              <text x="${n.x}" y="${n.y + 4}" text-anchor="middle" font-size="10" font-family="ui-monospace,monospace" fill="#111">${n.i},${n.j}</text>
            </g>`);
        }
        treeSvg.innerHTML = parts.join('');
        const tinfo = document.getElementById('treeInfo');
        tinfo.textContent = `ãƒãƒ¼ãƒ‰: ${nodes.length}, æ·±ã•: ${maxDepth}`;
      }

      function tick() {
        if (!running) return;
        stepOnce();
        if (finished) {
          running = false;
          stepTimer = null;
          return;
        }
        stepTimer = setTimeout(tick, stepDelay);
      }

      // UI ã‚¤ãƒ™ãƒ³ãƒˆ
      document.getElementById('algo').addEventListener('change', (e) => {
        algo = e.target.value;
        stop();
        resetState();
      });

      document.getElementById('play').addEventListener('click', () => {
        if (!running) {
          running = true;
          tick();
          document.getElementById('play').textContent = 'â¸ ä¸€æ™‚åœæ­¢';
        } else {
          stop();
        }
      });

      document.getElementById('step').addEventListener('click', () => {
        if (running) return; // å†ç”Ÿä¸­ã¯æ‰‹å‹•ã‚¹ãƒ†ãƒƒãƒ—ãªã—
        stepOnce();
      });

      document.getElementById('reset').addEventListener('click', () => {
        stop();
        clearLog();
        resetState();
      });

      document.getElementById('clearLog').addEventListener('click', () => {
        clearLog();
      });

      document.getElementById('speed').addEventListener('input', (e) => {
        stepDelay = Number(e.target.value);
      });

      function stop() {
        running = false;
        if (stepTimer) {
          clearTimeout(stepTimer);
          stepTimer = null;
        }
        document.getElementById('play').textContent = 'â–¶ å†ç”Ÿ';
      }

      // åˆæœŸåŒ–
      resetState();

      // ---- ãƒ­ã‚°é–¢æ•° ----
      function clearLog() {
        const el = document.getElementById('log');
        el.textContent = '';
      }
      function appendLog(line) {
        const el = document.getElementById('log');
        el.textContent += (el.textContent ? '\n' : '') + line;
        el.scrollTop = el.scrollHeight;
      }
      function fmtEntry(e) {
        if (!e) return '[]';
        const [i, j, d] = e;
        return `[${i}, ${j}, ${d}]`;
      }
      function serializeContainer(arr) {
        return '[' + arr.map(fmtEntry).join(', ') + ']';
      }
    </script>
  </body>
  </html>
