<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ACO - TSP デモ</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 10px;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: rgba(255,255,255,0.96);
      border-radius: 12px;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    h1 { text-align: center; margin: 0; color: #333; font-size: 1.2em; }

    .main {
      display: grid;
      grid-template-columns: 1fr; /* 一画面に収まるよう1カラム */
      gap: 10px;
      min-height: 0;
    }
    .panel { background: #fff; border-radius: 8px; box-shadow: 0 1px 4px rgba(0,0,0,0.06); padding: 4px; }

    /* Compact toolbar layout */
    .toolbar { display: flex; flex-wrap: wrap; align-items: center; gap: 6px 10px; }
    .tool { display: flex; align-items: center; gap: 4px; }
    .tool label { font-size: 0.75em; color: #444; font-weight: 700; }
    input[type="number"], input[type="range"] {
      padding: 4px 6px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 0.85em;
      background: #fafafa;
    }
    /* 数値入力ボックス短縮 */
    .controls .control-group input[type="number"],
    .toolbar .tool input[type="number"] {
      width: auto;
      max-width: 96px;
      align-self: start;
    }
    /* スライダーは適度に短縮 */
    .controls .control-group input[type="range"],
    .toolbar .tool input[type="range"] { width: 140px; }
    .row { display: flex; gap: 6px; align-items: center; }
    button {
      padding: 6px 10px;
      border: none;
      border-radius: 6px;
      font-size: 0.85em;
      font-weight: 700;
      cursor: pointer;
      transition: transform .15s ease, box-shadow .2s ease;
    }
    button:hover { transform: translateY(-1px); box-shadow: 0 4px 10px rgba(0,0,0,0.15); }
    .btn-start { background: linear-gradient(135deg,#667eea,#764ba2); color: #fff; min-width: 6.5em; white-space: nowrap; }
    .row button { white-space: nowrap; }
    .btn-reset { background: linear-gradient(135deg,#4facfe,#00f2fe); color: #fff; }
    .btn-random { background: linear-gradient(135deg,#f093fb,#f5576c); color: #fff; }
    /* .btn-clear removed */
    .hint { font-size: .75em; color: #666; }

    /* Compact status bar */
    .statusbar { display: flex; flex-wrap: wrap; align-items: center; gap: 10px; padding: 2px 4px; font-size: .8em; color: #374151; }
    .statusbar .v { color: #667eea; font-weight: 800; }

    .canvas-wrap { display: grid; grid-template-rows: auto auto; gap: 8px; }
    .square-area {
      width: 100%;
      /* サイズは JS で正方形に調整 */
      border: 1px solid #e5e7eb; border-radius: 10px; background: #f8fafc;
      overflow: hidden;
    }
    canvas { width: 100%; height: 100%; display: block; }

    .about { background: #fff; border-radius: 10px; padding: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); }
    .about h2 { margin: 0 0 6px; font-size: 1.05em; color: #333; }
    .about dl { display: grid; grid-template-columns: 7em 1fr; gap: 6px 10px; }
    .about dt { font-weight: 700; color: #444; }
    .about dd { margin: 0; color: #333; }

    @media (max-width: 900px) {
      .main { grid-template-columns: 1fr; }
      /* 高さは JS 側で調整 */
      .controls { grid-template-columns: repeat(2, 1fr); }
      .stats { grid-template-columns: repeat(2, 1fr); }
    }
  </style>
  <script>
    // --- Utility ---
    function dist(a, b) {
      const dx = a.x - b.x, dy = a.y - b.y; return Math.hypot(dx, dy);
    }

    // --- ACO Core ---
    class ACO {
      constructor(cities, opts) {
        this.cities = cities.slice();
        this.n = this.cities.length;
        this.alpha = opts.alpha ?? 1;
        this.beta = opts.beta ?? 5;
        this.rho = opts.rho ?? 0.5; // evaporation
        this.Q = opts.Q ?? 100;     // deposit constant
        this.antCount = opts.antCount ?? this.n;
        this.iter = 0;

        this.dist = Array.from({length: this.n}, () => Array(this.n).fill(0));
        for (let i = 0; i < this.n; i++) {
          for (let j = 0; j < this.n; j++) {
            this.dist[i][j] = i === j ? 0 : dist(this.cities[i], this.cities[j]);
          }
        }
        const tau0 = 1; // initial pheromone
        this.tau = Array.from({length: this.n}, () => Array(this.n).fill(tau0));
        this.bestTour = null;
        this.bestLen = Infinity;
      }

      tourLength(tour) {
        let L = 0;
        for (let i = 0; i < tour.length; i++) {
          const a = tour[i];
          const b = tour[(i + 1) % tour.length];
          L += this.dist[a][b];
        }
        return L;
      }

      buildTour() {
        const n = this.n;
        const start = Math.floor(Math.random() * n);
        const tour = [start];
        const visited = new Array(n).fill(false);
        visited[start] = true;
        while (tour.length < n) {
          const i = tour[tour.length - 1];
          let sum = 0;
          const probs = new Array(n).fill(0);
          for (let j = 0; j < n; j++) {
            if (!visited[j] && i !== j) {
              const eta = 1 / (this.dist[i][j] + 1e-9);
              const p = Math.pow(this.tau[i][j], this.alpha) * Math.pow(eta, this.beta);
              probs[j] = p; sum += p;
            }
          }
          let r = Math.random() * sum;
          let next = -1;
          for (let j = 0; j < n; j++) {
            if (probs[j] > 0) {
              r -= probs[j];
              if (r <= 0) { next = j; break; }
            }
          }
          if (next === -1) {
            // Fallback (can happen due to numeric): pick any unvisited
            for (let j = 0; j < n; j++) if (!visited[j] && j !== i) { next = j; break; }
          }
          tour.push(next);
          visited[next] = true;
        }
        return tour;
      }

      iterate() {
        const ants = [];
        for (let k = 0; k < this.antCount; k++) {
          const tour = this.buildTour();
          const L = this.tourLength(tour);
          ants.push({tour, L});
          if (L < this.bestLen) { this.bestLen = L; this.bestTour = tour.slice(); }
        }

        // Evaporation
        for (let i = 0; i < this.n; i++) {
          for (let j = 0; j < this.n; j++) {
            this.tau[i][j] *= (1 - this.rho);
            if (this.tau[i][j] < 1e-6) this.tau[i][j] = 1e-6;
          }
        }
        // Deposit from all ants
        for (const {tour, L} of ants) {
          const dTau = this.Q / (L + 1e-9);
          for (let i = 0; i < tour.length; i++) {
            const a = tour[i];
            const b = tour[(i + 1) % tour.length];
            this.tau[a][b] += dTau;
            this.tau[b][a] += dTau;
          }
        }

        // Optional elitist reinforcement (small)
        if (this.bestTour) {
          const dTau = (this.Q / (this.bestLen + 1e-9)) * 0.5;
          for (let i = 0; i < this.bestTour.length; i++) {
            const a = this.bestTour[i];
            const b = this.bestTour[(i + 1) % this.bestTour.length];
            this.tau[a][b] += dTau;
            this.tau[b][a] += dTau;
          }
        }

        this.iter++;
        return { iter: this.iter, bestLen: this.bestLen, bestTour: this.bestTour };
      }
    }

    // --- UI / Drawing ---
    let aco = null;
    let cities = [];
    let running = false; let timer = null;
    let showPheromone = false;
    let showPheroText = false;
    let showIndex = true;

    function randCities(n, w, h, margin=20) {
      const pts = [];
      for (let i = 0; i < n; i++) {
        pts.push({ x: margin + Math.random()*(w-2*margin), y: margin + Math.random()*(h-2*margin) });
      }
      return pts;
    }

    function initACO() {
      const alpha = parseFloat(document.getElementById('alpha').value);
      const beta = parseFloat(document.getElementById('beta').value);
      const rho = parseFloat(document.getElementById('rho').value);
      const Q = parseFloat(document.getElementById('Q').value);
      const ants = parseInt(document.getElementById('ants').value);
      aco = new ACO(cities, { alpha, beta, rho, Q, antCount: ants });
      updateStats({iter: 0, bestLen: Infinity});
      draw();
    }

    function updateStats({iter, bestLen}) {
      document.getElementById('iter').textContent = iter;
      document.getElementById('bestlen').textContent = Number.isFinite(bestLen) ? bestLen.toFixed(1) : '-';
      document.getElementById('citycount').textContent = cities.length;
    }

    function draw() {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0,0,w,h);

      // Draw best path
      if (aco && aco.bestTour && aco.bestTour.length > 0) {
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#10b981';
        ctx.beginPath();
        const tour = aco.bestTour;
        const s = cities[tour[0]];
        ctx.moveTo(s.x, s.y);
        for (let i = 1; i < tour.length; i++) {
          const p = cities[tour[i]];
          ctx.lineTo(p.x, p.y);
        }
        ctx.lineTo(s.x, s.y);
        ctx.stroke();
      }

      // Draw pheromone heat (optional faint)
      if (aco && showPheromone) {
        // normalize by max tau to map thickness
        let maxTau = 0;
        for (let i = 0; i < aco.n; i++) {
          for (let j = i+1; j < aco.n; j++) {
            if (aco.tau[i][j] > maxTau) maxTau = aco.tau[i][j];
          }
        }
        if (!(maxTau > 0)) maxTau = 1;

        ctx.save();
        ctx.globalAlpha = 0.25;
        ctx.strokeStyle = '#6366f1';
        for (let i = 0; i < aco.n; i++) {
          for (let j = i+1; j < aco.n; j++) {
            const tau = aco.tau[i][j];
            const norm = Math.min(1, tau / maxTau);
            if (norm < 0.02) continue; // skip extremely weak edges
            const strength = Math.sqrt(norm); // compress range
            ctx.lineWidth = 0.6 + strength * 3.6;
            ctx.beginPath();
            ctx.moveTo(cities[i].x, cities[i].y);
            ctx.lineTo(cities[j].x, cities[j].y);
            ctx.stroke();
          }
        }
        ctx.restore();
        if (showPheroText) {
          ctx.save();
          ctx.font = '10px system-ui';
          for (let i = 0; i < aco.n; i++) {
            for (let j = i+1; j < aco.n; j++) {
              const tau = aco.tau[i][j];
              const norm = Math.min(1, tau / maxTau);
              if (norm < 0.35) continue; // show only stronger edges to reduce clutter
              const mx = (cities[i].x + cities[j].x) / 2;
              const my = (cities[i].y + cities[j].y) / 2;
              const txt = (tau >= 100 ? tau.toFixed(0) : tau.toFixed(1));
              ctx.lineWidth = 3;
              ctx.strokeStyle = 'rgba(255,255,255,0.9)';
              ctx.strokeText(txt, mx, my);
              ctx.fillStyle = '#4338ca';
              ctx.fillText(txt, mx, my);
            }
          }
          ctx.restore();
        }
      }

      // Draw cities
      for (let i = 0; i < cities.length; i++) {
        const p = cities[i];
        // node shadow
        ctx.beginPath();
        ctx.fillStyle = 'rgba(17,24,39,0.08)';
        ctx.arc(p.x+1.5, p.y+1.5, 7, 0, Math.PI*2);
        ctx.fill();
        // node body
        ctx.beginPath();
        ctx.fillStyle = '#111827';
        ctx.arc(p.x, p.y, 6, 0, Math.PI*2);
        ctx.fill();
        // node ring
        ctx.beginPath();
        ctx.strokeStyle = '#a5b4fc';
        ctx.lineWidth = 1.5;
        ctx.arc(p.x, p.y, 8.5, 0, Math.PI*2);
        ctx.stroke();
        if (showIndex) {
          ctx.fillStyle = '#374151';
          ctx.font = '12px system-ui';
          ctx.fillText(String(i), p.x + 9, p.y - 9);
        }
      }
    }

    function sizeCanvas() {
      const wrap = document.getElementById('canvasWrap');
      const square = document.getElementById('square');
      const canvas = document.getElementById('canvas');
      const rect = wrap.getBoundingClientRect();
      const availableWidth = Math.floor(rect.width);
      // 画面高に依存した上限（説明を下に回すため控えめ）
      const maxByHeight = Math.floor(Math.min(window.innerHeight * 0.58, 520));
      const size = Math.max(100, Math.min(availableWidth, maxByHeight));
      square.style.width = size + 'px';
      square.style.height = size + 'px';
      square.style.margin = '0 auto';
      canvas.width = size;
      canvas.height = size;
    }

    function tick() {
      if (!aco) return;
      const speed = parseInt(document.getElementById('speed').value); // 1..10
      const stats = aco.iterate();
      updateStats(stats);
      draw();
      const maxIterInput = document.getElementById('maxIter');
      const maxIter = maxIterInput ? parseInt(maxIterInput.value) : Infinity;
      if (Number.isFinite(maxIter) && stats.iter >= maxIter) {
        running = false;
        if (timer) { clearTimeout(timer); timer = null; }
        const btn = document.getElementById('btnStart');
        if (btn) btn.textContent = '開始';
        return;
      }
      timer = setTimeout(() => { if (running) tick(); }, 1000/Math.max(1, speed));
    }

    function startStop() {
      if (!aco) initACO();
      running = !running;
      document.getElementById('btnStart').textContent = running ? '一時停止' : '開始';
      if (running) tick(); else if (timer) { clearTimeout(timer); timer = null; }
    }

    function reset() {
      running = false; if (timer) { clearTimeout(timer); timer = null; }
      document.getElementById('btnStart').textContent = '開始';
      initACO();
    }

    function randomizeCities() {
      const canvas = document.getElementById('canvas');
      const n = parseInt(document.getElementById('cityN').value);
      cities = randCities(n, canvas.width, canvas.height);
      reset();
      draw();
    }

    // clearCities removed (UI does not provide clear-all)

    function applyCityNFromInput() {
      const input = document.getElementById('cityN');
      const canvas = document.getElementById('canvas');
      let n = parseInt(input.value);
      if (!Number.isFinite(n)) return;
      n = Math.max(3, Math.min(200, n));
      input.value = n;
      const wasRunning = running;
      if (timer) { clearTimeout(timer); timer = null; }
      running = false;
      if (n > cities.length) {
        const extra = randCities(n - cities.length, canvas.width, canvas.height);
        cities = cities.concat(extra);
      } else if (n < cities.length) {
        cities = cities.slice(0, n);
      }
      initACO();
      draw();
      if (wasRunning) { startStop(); }
    }

    function onCanvasClick(ev) {
      const rect = ev.target.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      cities.push({x, y});
      initACO();
      draw();
    }

    window.addEventListener('load', () => {
      sizeCanvas();
      // Default cities
      cities = randCities(50, document.getElementById('canvas').width, document.getElementById('canvas').height);
      initACO();
      draw();
      document.getElementById('canvas').addEventListener('click', onCanvasClick);
      window.addEventListener('resize', () => { sizeCanvas(); draw(); });
      // toggles
      const pher = document.getElementById('togglePhero');
      const pherText = document.getElementById('togglePheroText');
      const idx = document.getElementById('toggleIndex');
      if (pher) pher.addEventListener('change', (e)=>{ showPheromone = e.target.checked; draw(); });
      if (pherText) pherText.addEventListener('change', (e)=>{ showPheroText = e.target.checked; draw(); });
      if (idx) idx.addEventListener('change', (e)=>{ showIndex = e.target.checked; draw(); });
      const cityInput = document.getElementById('cityN');
      if (cityInput) cityInput.addEventListener('change', applyCityNFromInput);
    });
  </script>
  </head>
  <body>
    <div class="container">
      <h1>🐜 アントコロニー最適化 (ACO) - TSP デモ</h1>

      <div class="main">
        <div class="panel">
          <div class="toolbar" style="margin-bottom:4px;">
            <div class="tool"><label for="cityN" title="都市数: キャンバス上の都市の数">都市</label><input id="cityN" type="number" value="50" min="3" max="200" title="都市数: キャンバス上の都市の数" /></div>
            <div class="tool"><label for="ants" title="アリ数/イテレーション: 1反復で経路を構築するアリの数。大きいほど探索の幅が増えるが計算量も増加">アリ</label><input id="ants" type="number" value="50" min="1" max="400" title="アリ数/イテレーション: 1反復で経路を構築するアリの数。大きいほど探索の幅が増えるが計算量も増加" /></div>
            <div class="tool"><label for="speed" title="速度: 描画更新頻度。大きいほど速い">速度 <span id="speedV">5</span></label>
              <input id="speed" type="range" min="1" max="10" step="1" value="5" oninput="document.getElementById('speedV').textContent=this.value" title="速度: 描画更新頻度。大きいほど速い" />
            </div>
            <div class="tool"><label for="maxIter" title="打ち切りステップ数: 指定した反復数に到達すると自動停止">打ち切り</label><input id="maxIter" type="number" value="200" min="1" max="100000" title="打ち切りステップ数: 指定した反復数に到達すると自動停止" /></div>
            <div class="tool"><label for="alpha" title="α: フェロモンの重み。大きいほど既存の道(τ)を重視">α: フェロモン重み</label><input id="alpha" type="number" step="0.1" value="1.0" title="α: フェロモンの重み。大きいほど既存の道(τ)を重視" /></div>
            <div class="tool"><label for="beta" title="β: ヒューリスティックの重み。大きいほど近距離(η=1/距離)を重視">β: ヒューリスティック重み</label><input id="beta" type="number" step="0.1" value="5.0" title="β: ヒューリスティックの重み。大きいほど近距離(η=1/距離)を重視" /></div>
            <div class="tool"><label for="rho" title="ρ: 蒸発率(0..1)。大きいほどフェロモンが早く減衰し探索が拡散">ρ: 蒸発率</label><input id="rho" type="number" step="0.05" min="0" max="1" value="0.5" title="ρ: 蒸発率(0..1)。大きいほどフェロモンが早く減衰し探索が拡散" /></div>
            <div class="tool"><label for="Q" title="Q: 付与量係数。各アリの経路に Q/L を加算(Lは経路長)">Q: 付与量</label><input id="Q" type="number" step="1" value="100" title="Q: 付与量係数。各アリの経路に Q/L を加算(Lは経路長)" /></div>
            <div class="tool" style="gap:10px;">
              <label class="hint" style="display:flex; align-items:center; gap:6px;" title="フェロモンの可視化を切り替え">
                <input id="togglePhero" type="checkbox" /> フェロモン表示
              </label>
              <label class="hint" style="display:flex; align-items:center; gap:6px;" title="各エッジにフェロモン量(τ)の数値を表示">
                <input id="togglePheroText" type="checkbox" /> フェロモン量
              </label>
              <label class="hint" style="display:flex; align-items:center; gap:6px;" title="都市番号の表示を切り替え">
                <input id="toggleIndex" type="checkbox" checked /> 番号
              </label>
            </div>
            <div class="tool">
              <div class="row" style="flex-wrap: wrap;">
                <button id="btnStart" class="btn-start" onclick="startStop()">開始</button>
                <button class="btn-reset" onclick="reset()">リセット</button>
                <button class="btn-random" onclick="randomizeCities()">ランダム</button>
                
              </div>
            </div>
          </div>

          <div class="statusbar">
            <span>iter <span class="v" id="iter">0</span></span>
            <span>best <span class="v" id="bestlen">-</span></span>
            <span>n <span class="v" id="citycount">0</span></span>
            <span class="hint">クリックで都市追加</span>
          </div>

          <div id="canvasWrap" class="canvas-wrap">
            <div class="hint">黒点＝都市, 緑線＝最良経路, 薄紫＝フェロモン（表示切替可）</div>
            <div id="square" class="square-area">
              <canvas id="canvas"></canvas>
            </div>
          </div>
        </div>
      </div>

      <!-- 説明はページ下部（スクロールで表示） -->
      <div class="panel about">
        <h2>このデモについて</h2>
        <dl>
          <dt>目的</dt>
          <dd>アントコロニー最適化 (ACO) により、巡回セールスマン問題 (TSP) の近似解探索の様子を可視化します。</dd>
          <dt>遷移確率</dt>
          <dd>未訪問都市 j への遷移確率は (τ<sub>ij</sub>)<sup>α</sup>(η<sub>ij</sub>)<sup>β</sup> に比例します。η は 1/距離、τ はフェロモン量、α・β はそれぞれの重みです。</dd>
          <dt>フェロモン更新</dt>
          <dd>各イテレーションで蒸発率 ρ で減衰し、各アリの経路に Q/L (L は経路長) を付与します。加えて最良経路へ弱い強化を行っています。</dd>
          <dt>パラメータ</dt>
          <dd>
            <ul>
              <li><strong>都市数</strong>: キャンバス上の都市の数。多いほど経路探索が難しくなる。</li>
              <li><strong>アリ数/イテレーション</strong>: 1反復で経路を構築するアリの数。多いほど探索の幅は広がるが計算量が増える。</li>
              <li><strong>速度</strong>: 描画の更新速度。数値が大きいほど速く進行。</li>
              <li><strong>打ち切り</strong>: 指定反復数に到達すると自動停止（実験時間の制御に便利）。</li>
              <li><strong>α (アルファ)</strong>: フェロモン τ の重み。大きいほど過去に強化された道を選びやすくなる（集約）。</li>
              <li><strong>β (ベータ)</strong>: ヒューリスティック η=1/距離 の重み。大きいほど近い都市を優先する（貪欲）。</li>
              <li><strong>ρ (ロー)</strong>: 蒸発率 0..1。大きいほどフェロモンが早く減少し、探索が拡散傾向に。</li>
              <li><strong>Q</strong>: フェロモン付与量の係数。各アリの経路に Q/L を加算（L は経路長）。</li>
              <li><strong>フェロモン表示</strong>: グラフ上の薄紫線で τ を可視化。非表示にすると最良経路のみ表示。</li>
              <li><strong>都市番号表示</strong>: 各都市のインデックスを表示/非表示。</li>
            </ul>
          </dd>
          <dt>操作</dt>
          <dd>
            ・「都市をランダム生成」で初期配置を作成。キャンバスをクリックして都市を追加できます。<br/>
            ・開始/一時停止、パラメータ調整、リセットが可能です。
          </dd>
        </dl>
      </div>
    </div>
  </body>
</html>
