<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GP å›å¸°ãƒ‡ãƒ¢ï¼ˆéºä¼çš„ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ï¼‰</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 10px;
    }
    .container {
      max-width: 1000px;
      margin: 0 auto;
      background: rgba(255,255,255,0.96);
      border-radius: 12px;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    h1 { text-align: center; margin: 0; color: #333; font-size: 1.2em; }
    .panel { background: #fff; border-radius: 8px; box-shadow: 0 1px 4px rgba(0,0,0,0.06); padding: 8px; }
    .toolbar { display: flex; flex-wrap: wrap; align-items: center; gap: 8px 12px; }
    .tool { display: flex; align-items: center; gap: 6px; }
    .tool label { font-size: 0.8em; color: #444; font-weight: 700; }
    input[type="number"], select { padding: 4px 6px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9em; background: #fafafa; }
    button { padding: 6px 10px; border: none; border-radius: 6px; font-size: 0.85em; font-weight: 700; cursor: pointer; }
    .btn-start { background: linear-gradient(135deg,#667eea,#764ba2); color: #fff; }
    .btn-reset { background: linear-gradient(135deg,#4facfe,#00f2fe); color: #fff; }
    .statusbar { display: flex; flex-wrap: wrap; align-items: center; gap: 10px; padding: 2px 4px; font-size: .85em; color: #374151; }
    .statusbar .v { color: #667eea; font-weight: 800; }
    canvas { width: 100%; height: 360px; border: 1px solid #e5e7eb; border-radius: 10px; background: #f8fafc; }
    .about h2 { margin: 0 0 6px; font-size: 1.05em; color: #333; }
    .code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: #f3f4f6; padding: 2px 6px; border-radius: 4px; }
  </style>
  <script>
    // --- ç›®æ¨™ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ ---
    function targetFn(x, kind) {
      switch (kind) {
        case 'sinx_plus_x': return Math.sin(x) + x;
        case 'poly3': return 0.5*x*x*x - x*x + 0.5*x;
        case 'abs_sin': return Math.abs(Math.sin(1.5*x)) + 0.2*x;
        default: return Math.sin(x) + x;
      }
    }

    function makeDataset(n, xMin, xMax, noise, kind) {
      const xs = [], ys = [];
      for (let i = 0; i < n; i++) {
        const t = i/(n-1);
        const x = xMin + (xMax - xMin) * t;
        const y = targetFn(x, kind) + (noise>0 ? (noise * (Math.random()*2-1)) : 0);
        xs.push(x); ys.push(y);
      }
      return { xs, ys };
    }

    // --- æœ¨æ§‹é€ ï¼ˆå¼æœ¨ï¼‰è¡¨ç¾ ---
    const FuncSet = ['+','-','*','/','sin','cos','exp','log'];
    const TermSet = ['x','const'];

    function randChoice(arr) { return arr[Math.floor(Math.random()*arr.length)]; }

    function newConst() { return { type: 'const', value: (Math.random()*2-1)*2 }; }

    function clone(node) { return JSON.parse(JSON.stringify(node)); }

    function randTree(maxDepth) {
      if (maxDepth === 0) {
        const t = randChoice(TermSet);
        return t === 'x' ? { type:'x' } : newConst();
      }
      const chooseFunc = Math.random() < 0.7; // è‘‰ã°ã‹ã‚Šã«ãªã‚‰ãªã„ã‚ˆã†é–¢æ•°ã‚’å„ªå…ˆ
      if (!chooseFunc) {
        const t = randChoice(TermSet);
        return t === 'x' ? { type:'x' } : newConst();
      }
      const f = randChoice(FuncSet);
      if (['+','-','*','/'].includes(f)) {
        return { type:'op', op:f, left: randTree(maxDepth-1), right: randTree(maxDepth-1) };
      } else { // å˜é …
        return { type:'uop', op:f, arg: randTree(maxDepth-1) };
      }
    }

    function treeEval(node, x) {
      switch (node.type) {
        case 'x': return x;
        case 'const': return node.value;
        case 'op': {
          const a = treeEval(node.left, x), b = treeEval(node.right, x);
          switch (node.op) {
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
            case '/': return Math.abs(b) < 1e-9 ? a : a / b; // 0å‰²å›é¿
          }
          return 0;
        }
        case 'uop': {
          const v = treeEval(node.arg, x);
          switch (node.op) {
            case 'sin': return Math.sin(v);
            case 'cos': return Math.cos(v);
            case 'exp': return Math.exp(Math.max(-20, Math.min(20, v))); // ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼æŠ‘åˆ¶
            case 'log': return Math.log(Math.abs(v)+1e-6);
          }
          return 0;
        }
      }
      return 0;
    }

    function treeToString(node) {
      switch (node.type) {
        case 'x': return 'x';
        case 'const': return node.value.toFixed(3);
        case 'op': return `(${treeToString(node.left)} ${node.op} ${treeToString(node.right)})`;
        case 'uop': return `${node.op}(${treeToString(node.arg)})`;
        default: return '?';
      }
    }

    function treeSize(node) {
      if (!node) return 0;
      if (node.type === 'op') return 1 + treeSize(node.left) + treeSize(node.right);
      if (node.type === 'uop') return 1 + treeSize(node.arg);
      return 1;
    }

    // --- é©å¿œåº¦ï¼ˆMSE + ç½°å‰‡ï¼‰ ---
    function fitness(node, xs, ys) {
      let se = 0;
      for (let i = 0; i < xs.length; i++) {
        const yhat = treeEval(node, xs[i]);
        const diff = yhat - ys[i];
        se += diff*diff;
      }
      const mse = se / xs.length;
      const penalty = 1e-3 * Math.max(0, treeSize(node) - 40); // è¤‡é›‘ã•æŠ‘åˆ¶
      return mse + penalty;
    }

    // --- é¸æŠãƒ»äº¤å‰ãƒ»çªç„¶å¤‰ç•° ---
    function tournamentSelect(pop, k) {
      let best = null, bestF = Infinity;
      for (let i = 0; i < k; i++) {
        const cand = pop[Math.floor(Math.random()*pop.length)];
        if (cand.f < bestF) { best = cand; bestF = cand.f; }
      }
      return best;
    }

    function randomSubtree(node) {
      // å‰é †èµ°æŸ»ã§ãƒãƒ¼ãƒ‰ã‚’é…åˆ—åŒ–ã—ã€ãƒ©ãƒ³ãƒ€ãƒ é¸æŠ
      const nodes = [];
      (function dfs(n){ if(!n) return; nodes.push(n); if(n.type==='op'){ dfs(n.left); dfs(n.right);} else if(n.type==='uop'){ dfs(n.arg);} })(node);
      return nodes[Math.floor(Math.random()*nodes.length)];
    }

    function crossover(a, b, maxDepth) {
      const na = clone(a), nb = clone(b);
      // å‚ç…§å·®ã—æ›¿ãˆã®ãŸã‚ã€è¦ªã‚’è¾¿ã£ã¦ç½®æ›
      function replaceRandom(parent) {
        const isBin = parent.type==='op';
        const isUni = parent.type==='uop';
        const choices = [];
        if (isBin) { choices.push(['left'], ['right']); }
        if (isUni) { choices.push(['arg']); }
        // è‘‰ã¯ç½®æ›å¯¾è±¡ã«ã—ãªã„ï¼ˆè¦ªãƒãƒ¼ãƒ‰ã‹ã‚‰å·®ã—æ›¿ãˆã‚‹ï¼‰
        const path = choices.length ? randChoice(choices) : null;
        if (!path) return null;
        return { parent, path };
      }
      const spotA = replaceRandom(na);
      const spotB = replaceRandom(nb);
      if (!spotA || !spotB) return na; // ç‰‡æ–¹ãŒè‘‰ã®ã¿ãªã‚‰ç„¡å¤‰æ›´
      // ç½®æ›ã™ã‚‹éƒ¨åˆ†æœ¨ã‚’ãƒ©ãƒ³ãƒ€ãƒ å–å¾—
      const subA = randomSubtree(spotA.parent[spotA.path[0]]);
      const subB = randomSubtree(spotB.parent[spotB.path[0]]);
      // æ·±ã•åˆ¶ç´„ã‚’è»½ããƒã‚§ãƒƒã‚¯ï¼ˆå³å¯†ã§ãªããƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯ï¼‰
      spotA.parent[spotA.path[0]] = clone(subB);
      spotB.parent[spotB.path[0]] = clone(subA);
      return na;
    }

    function mutate(node, maxDepth, pm = 0.1) {
      const n = clone(node);
      function rec(cur, depth) {
        if (Math.random() < pm) {
          return randTree(Math.max(0, maxDepth - depth));
        }
        if (cur.type === 'op') {
          return { type:'op', op: cur.op, left: rec(cur.left, depth+1), right: rec(cur.right, depth+1) };
        } else if (cur.type === 'uop') {
          return { type:'uop', op: cur.op, arg: rec(cur.arg, depth+1) };
        } else if (cur.type === 'const') {
          // å®šæ•°å¾®å°å¤‰ç•°
          if (Math.random() < pm) return { type:'const', value: cur.value + (Math.random()*2-1)*0.5 };
          return cur;
        }
        return cur;
      }
      return rec(n, 0);
    }

    // --- ãƒ©ãƒ³åŸ·è¡Œãƒ«ãƒ¼ãƒ— ---
    let dataset = null;
    let pop = [];
    let best = null;
    let running = false;
    let timer = null;

    function initGP() {
      const nData = parseInt(document.getElementById('nData').value);
      const xMin = parseFloat(document.getElementById('xMin').value);
      const xMax = parseFloat(document.getElementById('xMax').value);
      const noise = parseFloat(document.getElementById('noise').value);
      const kind = document.getElementById('dataset').value;
      dataset = makeDataset(nData, xMin, xMax, noise, kind);

      const popSize = parseInt(document.getElementById('popSize').value);
      const maxDepth = parseInt(document.getElementById('maxDepth').value);

      pop = [];
      for (let i = 0; i < popSize; i++) {
        const ind = randTree(maxDepth);
        const f = fitness(ind, dataset.xs, dataset.ys);
        pop.push({ ind, f });
      }
      best = pop.reduce((a,b)=> a.f<b.f?a:b);
      updateStats(0, best.f, best.ind);
      draw();
    }

    function step(gen) {
      const popSize = parseInt(document.getElementById('popSize').value);
      const maxDepth = parseInt(document.getElementById('maxDepth').value);
      const pC = parseFloat(document.getElementById('pC').value);
      const pM = parseFloat(document.getElementById('pM').value);
      const tourK = parseInt(document.getElementById('tourK').value);
      const elitism = document.getElementById('elit').checked ? 1 : 0;

      const next = [];
      // ã‚¨ãƒªãƒ¼ãƒˆä¿æŒ
      const sorted = [...pop].sort((a,b)=>a.f-b.f);
      for (let i = 0; i < elitism; i++) next.push({ ind: clone(sorted[i].ind), f: sorted[i].f });

      while (next.length < popSize) {
        const a = tournamentSelect(pop, tourK);
        const b = tournamentSelect(pop, tourK);
        let child = Math.random() < pC ? crossover(a.ind, b.ind, maxDepth) : clone(a.ind);
        child = Math.random() < pM ? mutate(child, maxDepth, 0.1) : child;
        const f = fitness(child, dataset.xs, dataset.ys);
        next.push({ ind: child, f });
      }
      pop = next;
      const curBest = pop.reduce((x,y)=> x.f<y.f?x:y);
      if (!best || curBest.f < best.f) best = { ind: clone(curBest.ind), f: curBest.f };
      updateStats(gen, best.f, best.ind);
      draw();
    }

    function updateStats(gen, bestF, bestInd) {
      document.getElementById('gen').textContent = gen;
      document.getElementById('bestF').textContent = bestF.toExponential(3);
      document.getElementById('expr').textContent = treeToString(bestInd);
      document.getElementById('size').textContent = treeSize(bestInd);
    }

    function draw() {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const w = canvas.width = canvas.clientWidth;
      const h = canvas.height = canvas.clientHeight;

      // è»¸ç¯„å›²
      const xMin = parseFloat(document.getElementById('xMin').value);
      const xMax = parseFloat(document.getElementById('xMax').value);

      // yç¯„å›²æ¨å®š
      let yMin = Infinity, yMax = -Infinity;
      for (let i = 0; i < dataset.xs.length; i++) { yMin = Math.min(yMin, dataset.ys[i]); yMax = Math.max(yMax, dataset.ys[i]); }
      // ãƒ™ã‚¹ãƒˆå¼ã‚‚ã‚¹ã‚­ãƒ£ãƒ³
      for (let i = 0; i < 200; i++) {
        const x = xMin + (xMax - xMin) * (i/199);
        const y = treeEval(best.ind, x);
        yMin = Math.min(yMin, y); yMax = Math.max(yMax, y);
      }
      if (!(yMax>yMin)) { yMin = -1; yMax = 1; }
      const pad = 0.1*(yMax - yMin + 1e-9);
      yMin -= pad; yMax += pad;

      function X(x) { return (x - xMin) / (xMax - xMin) * (w-40) + 20; }
      function Y(y) { return h - ((y - yMin) / (yMax - yMin)) * (h-40) - 20; }

      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0,0,w,h);

      // è»¸
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1;
      ctx.strokeRect(20,20,w-40,h-40);

      // ãƒ‡ãƒ¼ã‚¿ç‚¹
      ctx.fillStyle = '#111827';
      for (let i = 0; i < dataset.xs.length; i++) {
        const x = X(dataset.xs[i]);
        const y = Y(dataset.ys[i]);
        ctx.beginPath(); ctx.arc(x, y, 2.2, 0, Math.PI*2); ctx.fill();
      }

      // ç›®æ¨™é–¢æ•°ï¼ˆç†æƒ³ï¼‰
      ctx.strokeStyle = '#9ca3af'; // ç°
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      for (let i = 0; i < 200; i++) {
        const t = i/199;
        const x = xMin + (xMax - xMin) * t;
        const y = targetFn(x, document.getElementById('dataset').value);
        const xp = X(x), yp = Y(y);
        if (i===0) ctx.moveTo(xp, yp); else ctx.lineTo(xp, yp);
      }
      ctx.stroke();

      // äºˆæ¸¬ï¼ˆãƒ™ã‚¹ãƒˆå€‹ä½“ï¼‰
      ctx.strokeStyle = '#10b981'; // ç·‘
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      for (let i = 0; i < 200; i++) {
        const t = i/199;
        const x = xMin + (xMax - xMin) * t;
        const y = treeEval(best.ind, x);
        const xp = X(x), yp = Y(y);
        if (i===0) ctx.moveTo(xp, yp); else ctx.lineTo(xp, yp);
      }
      ctx.stroke();
    }

    function tick(gen) {
      if (!running) return;
      const maxGen = parseInt(document.getElementById('maxGen').value);
      const speed = parseInt(document.getElementById('speed').value);
      if (gen >= maxGen) { running = false; return; }
      step(gen+1);
      timer = setTimeout(() => tick(gen+1), 1000/Math.max(1, speed));
    }

    function startStop() {
      if (!dataset) initGP();
      running = !running;
      document.getElementById('btnStart').textContent = running ? 'ä¸€æ™‚åœæ­¢' : 'é–‹å§‹';
      if (running) tick(parseInt(document.getElementById('gen').textContent) || 0);
      else if (timer) { clearTimeout(timer); timer = null; }
    }

    function resetAll() {
      running = false; if (timer) { clearTimeout(timer); timer = null; }
      document.getElementById('btnStart').textContent = 'é–‹å§‹';
      initGP();
    }

    window.addEventListener('load', () => {
      initGP();
      draw();
      window.addEventListener('resize', draw);
    });
  </script>
</head>
<body>
  <div class="container">
    <h1>ğŸ§¬ éºä¼çš„ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ï¼ˆGPï¼‰ã«ã‚ˆã‚‹å›å¸°ãƒ‡ãƒ¢</h1>
    <div class="panel">
      <div class="toolbar">
        <div class="tool"><label for="dataset">ãƒ‡ãƒ¼ã‚¿</label>
          <select id="dataset" onchange="resetAll()">
            <option value="sinx_plus_x">sin(x)+x</option>
            <option value="poly3">å¤šé …å¼3æ¬¡</option>
            <option value="abs_sin">|sin(1.5x)|+0.2x</option>
          </select>
        </div>
        <div class="tool"><label for="nData">ç‚¹æ•°</label><input id="nData" type="number" value="60" min="10" max="400" onchange="resetAll()" /></div>
        <div class="tool"><label for="xMin">xæœ€å°</label><input id="xMin" type="number" value="-3.14" step="0.1" onchange="resetAll()" /></div>
        <div class="tool"><label for="xMax">xæœ€å¤§</label><input id="xMax" type="number" value="3.14" step="0.1" onchange="resetAll()" /></div>
        <div class="tool"><label for="noise">ãƒã‚¤ã‚º</label><input id="noise" type="number" value="0.0" step="0.05" min="0" max="1" onchange="resetAll()" /></div>
      </div>
      <div class="toolbar" style="margin-top:6px;">
        <div class="tool"><label for="popSize">å€‹ä½“æ•°</label><input id="popSize" type="number" value="80" min="10" max="500" onchange="resetAll()" /></div>
        <div class="tool"><label for="maxDepth">æœ€å¤§æ·±ã•</label><input id="maxDepth" type="number" value="5" min="2" max="10" onchange="resetAll()" /></div>
        <div class="tool"><label for="pC">äº¤å‰ç‡</label><input id="pC" type="number" value="0.9" step="0.05" min="0" max="1" /></div>
        <div class="tool"><label for="pM">çªç„¶å¤‰ç•°ç‡</label><input id="pM" type="number" value="0.2" step="0.05" min="0" max="1" /></div>
        <div class="tool"><label for="tourK">ãƒˆãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆk</label><input id="tourK" type="number" value="3" min="2" max="8" /></div>
        <div class="tool"><label><input id="elit" type="checkbox" checked /> ã‚¨ãƒªãƒ¼ãƒˆä¿æŒ</label></div>
        <div class="tool"><label for="maxGen">æ‰“ã¡åˆ‡ã‚Š</label><input id="maxGen" type="number" value="200" min="1" max="2000" /></div>
        <div class="tool"><label for="speed">é€Ÿåº¦</label><input id="speed" type="number" value="5" min="1" max="30" /></div>
        <div class="tool">
          <button id="btnStart" class="btn-start" onclick="startStop()">é–‹å§‹</button>
          <button class="btn-reset" onclick="resetAll()">ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
      </div>

      <div class="statusbar">
        <span>gen <span class="v" id="gen">0</span></span>
        <span>best MSE <span class="v" id="bestF">-</span></span>
        <span>size <span class="v" id="size">-</span></span>
        <span>expr <span class="v code" id="expr">-</span></span>
      </div>

      <canvas id="canvas"></canvas>
    </div>

    <div class="panel about">
      <h2>ã“ã®ãƒ‡ãƒ¢ã«ã¤ã„ã¦</h2>
      <p>
        éºä¼çš„ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ï¼ˆGenetic Programming; GPï¼‰ã‚’ç”¨ã„ã¦ã€é€£ç¶šé–¢æ•°ã®å›å¸°è¿‘ä¼¼ã‚’è¡Œã„ã¾ã™ã€‚<br/>
        å€‹ä½“ã¯å¼æœ¨ï¼ˆæŠ½è±¡æ§‹æ–‡æœ¨ï¼‰ã§è¡¨ç¾ã—ã€äºŒé …æ¼”ç®—ï¼ˆ+,-,*,/ï¼‰ã¨å˜é …æ¼”ç®—ï¼ˆsin,cos,exp,logï¼‰ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚
      </p>
      <ul>
        <li><b>é©å¿œåº¦</b>: äºŒä¹—èª¤å·®ã®å¹³å‡ï¼ˆMSEï¼‰ã«å°ã•ãªè¤‡é›‘åº¦ãƒšãƒŠãƒ«ãƒ†ã‚£ã‚’åŠ ãˆã¾ã™ã€‚</li>
        <li><b>é¸æŠ</b>: ãƒˆãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆé¸æŠã€‚</li>
        <li><b>äº¤å‰</b>: ãƒ©ãƒ³ãƒ€ãƒ éƒ¨åˆ†æœ¨ã®ç½®æ›ï¼ˆç°¡æ˜“ç‰ˆï¼‰ã€‚</li>
        <li><b>çªç„¶å¤‰ç•°</b>: éƒ¨åˆ†æœ¨ã®ç½®æ›ã¨å®šæ•°å¾®å°å¤‰ç•°ã€‚</li>
        <li><b>ã‚¨ãƒªãƒ¼ãƒˆä¿æŒ</b>: æœ€è‰¯å€‹ä½“ã‚’æ¬¡ä¸–ä»£ã«æ¸©å­˜ï¼ˆä»»æ„ï¼‰ã€‚</li>
      </ul>
      <p>ãƒã‚¤ã‚ºã‚’åŠ ãˆã‚‹ã¨éå­¦ç¿’å‚¾å‘ãŒè¦‹ã‚„ã™ããªã‚Šã¾ã™ã€‚æœ€å¤§æ·±ã•ã‚„ãƒšãƒŠãƒ«ãƒ†ã‚£ã§è¤‡é›‘åº¦ã‚’æŠ‘åˆ¶ã§ãã¾ã™ã€‚</p>
    </div>
  </div>
</body>
</html>

